<!DOCTYPE html><meta charset="utf-8"><html lang="en"><head><title>Block 2</title><link rel="stylesheet" href="../assets/css/main.css"><link rel="stylesheet" href="../assets/css/prism.css"></head></html><body><div class="container"><header><h1>Software Engineering &mdash; Lab 2</h1><p>Spring 2014</p></header><div class="preamble"><p>In this block we'll focus on <em>testing</em> and <em>refactoring</em>. While there are many ways to test code we will focus on unit testing. In essance, unit testing means testing individual methods/functions in isolation. Asserting that some given input yield expected output.</p><p>The first exercise will focus on building the same application three times, employing different testing strategies.</p><ol><li><a href="http://stackoverflow.com/questions/7199313/what-are-the-pitfalls-of-test-after-development">Test-after development </a>, </li><li> <a href="http://www.extremeprogramming.org/rules/testfirst.html">Test-first development </a>(or more specifically <a href="http://en.wikipedia.org/wiki/Test-driven_development">Test-driven development</a>), and finally</li><li><a href="http://stackoverflow.com/questions/7690238/test-driven-development-initial-implementation">Exceptionally strict test-driven development</a> &mdash; often dubbed "sliming".</li></ol><p>After having familiarized ourselves with some different "schools" of testing we will focus on how we can use testing to locate bugs. Not only are tests an effective means for isolating the source of a bug, but also &mdash; when we're using tests to locate bugs, we're also "locking in" the bug. Having a test that targets a specific bug means it will be increasingly hard to accidentally reintroduce the same bug unnoticed.</p><p>In the third exercise we'll look at <em>test coverage</em>, often times called <a href="http://en.wikipedia.org/wiki/Code_coverage">code coverage</a>. It intends to be a measure of how much of a code base that is tested. It's value as a measure is an <a href="http://martinfowler.com/bliki/TestCoverage.html">issue of debate</a>.</p><p>In the fourth exercise we'll take a step back from testing and look at refactoring existing code. Using the classic example <a href="http://www.cs.unc.edu/~stotts/723/refactor/chap1.html">movie rental case</a> by <a href="http://en.wikipedia.org/wiki/Martin_Fowler">Martin Fowler</a>.</p><p>Lastly we'll look at how we can use tests to "drive" the process of designing a code base. <a href="http://stackoverflow.com/questions/7538744/is-test-driven-development-the-same-as-test-driven-design">Test-Driven Design</a> is essentially the same idea as Test-Driven Development. However adding the explicit claim that code design will improve through TDD.</p></div><h2>Study material</h2><p>Please do familiarize yourself with the following study material <strong>before</strong> attempting to approach the corresponding lab exercises.</p><h3>Test-driven development</h3><ul><li><a href="https://www.youtube.com/watch?v=QCif_-r8eK4">What is TDD?</a> (~5 min video)</li><li><a href="https://www.youtube.com/watch?v=xX9hfPkA800">A TDD pair-programming session</a> (~2 h video)</li></ul><h3>Refactoring</h3><ul><li><a href="http://www.cs.unc.edu/~stotts/723/refactor/chap1.html">Refactoring, a first example</a> (A great example of refactoring by Martin Fowler)</li><li>Examples of Martin Fowler's refactoring technique (from his book <a href="http://martinfowler.com/books/refactoring.html">Refactoring &mdash; Improving the design of existing code</a>). Explained by some dude on youtube.<ul><li><a href="https://www.youtube.com/playlist?list=PL3GKSsHsE_qKWl5-XWAX6jACpfId_9-8Y">Composing methods</a> (video playlist)</li><li><a href="https://www.youtube.com/playlist?list=PL3GKSsHsE_qJX-E7GuBkKJ8-BoyiThrk7">Moving Features Between Objects</a> (video playlist)</li><li><a href="https://www.youtube.com/playlist?list=PL3GKSsHsE_qJ54Q3oJ3GNVj8WkFZd6y2y">Organizing data</a> (video playlist)</li><li><a href="https://www.youtube.com/playlist?list=PL3GKSsHsE_qIv4gbun2h268rBc2-RnyNH">Simplifying Conditional Expressions</a> (video playlist)</li><li><a href="https://www.youtube.com/playlist?list=PL3GKSsHsE_qJwgtU88VFGq6cmewrdorxh">Making Method Calls Simpler</a> (video playlist)</li><li><a href="https://www.youtube.com/playlist?list=PL3GKSsHsE_qLVoAoWooC0yk59RLwV4rfW">Dealing With Generalization</a> (video playlist)</li></ul></li></ul><h2>Deliverables</h2><p>This is a summary of the deliverables for this block.</p><h3>Exercise 1 &mdash; <a href="#exercise-1">Introduction to testing</a></h3><p>Three Visual Studio projects (preferably in the same solution) and one text file.</p><ol><li>Testing (Visual Studio solution containing the following projects..)</li><ol><li>TAD (<em>Visual Studio</em> project)</li><li>TDD (<em>Visual Studio</em> project)</li><li>Sliming (visual Studio project)</li></ol><li>Contemplation (text document in <code>.txt</code> format)</li></ol><h3>Exercise 2 &mdash; <a href="#exercise-2">Debugging via Tests</a></h3><p>One Visual Studio solution and one text file.</p><ol><li>Matrix (<em>Visual Studio</em> solution)</li><li>Contemplation (Text file in <code>.txt</code>-format)</li></ol><h3>Exercise 3 &mdash; <a href="#exercise-3">Test Coverage</a></h3><p>One Visual Studio solution and one diagram.</p><ol><li>PhoneBook (<em>Visual Studio</em> solution)</li><li>Contemplation (Text-file in <code>.txt</code>-format)</li></ol><h3>Exercise 4 &mdash; <a href="#exercise-4">Refactoring</a></h3><p>One Visual Studio solution and one text file.</p><ol><li>MovieRental (<em>Visual Studio</em> solution)</li><li>Contemplation (Text-file in <code>.txt</code>-format)</li></ol><h3>Exercise 5 &mdash; <a href="#exercise-5">TDD Practice <strong>(optional)</strong></a></h3><p>One Visual Studio solution and one text file.</p><ol><li>BowlingGameKata (<em>Visual Studio</em> solution)</li><li>Contemplation (Text-file in <code>.txt</code>-format)</li></ol><h2 id="exercise-1">Exercise 1 &mdash; Introduction to testing</h2><p>In this first exercise we want you to approach the same problem using three more or less different strategies. After that we'll reflect over their differences.</p><h3>Test-after development</h3><p>You've been provided with a project containing a working implementation of the FizzBuzz problem. Your job is to write unit tests with reasonable coverage. When you are done, it should be hard to introduce errors to the application without also making tests fail. At a minimum, write tests for the following cases:</p><ul><li><code>Fizz</code> is returned, when given some number divisible by 3</li><li><code>Buzz</code> is returned, when given some number divisible by 5</li><li><code>FizzBuzz</code> is returned, when given some number divisible by 3 <strong>and</strong> 5</li><li>The input number itself is returned, when given some input number not divisible by 3 <strong>nor</strong> 5</li></ul><p>If you can't remember what the rules of the FizzBuzz game are, then the above cases is basically an explanation for the rules of the game (if you change the word "some" for "any").</p><p>Are these tests enough?</p><p>While the answer to this question of course greatly depends on how you have written your tests, it is quite likely that the answer is no. Do keep this question in mind as you approximate the section on "sliming".</p><h3>Test-driven development</h3><p>Create a new console project. We're now going to build the FizzBuzz application again, but this time through test-driven development (TDD). Basically this means that we must build our application only by iterating the steps below:</p><ol><li>Introduce a (or change an existing) test</li><li>Watch the test fail (for the right reason)</li><li>Write the minimal code needed to make it pass</li></ol><p>Different schools of thought argue the meaning of "minimal code needed". However, in this exercise, think of it as: writing the simplest production code possible, that reflects the "idea" of the test, making it pass.</p><p>An easy way to remember the above steps is to think of the idiom red-green-refactor. Basically it means that we should produce a state where some test fail (red). Then write enough code to make it pass (green). Only then, are we allowed to refactor code.</p><h3>New requirements</h3><p>This time we'll introduce a new requirements. Apart from the <code>FizzOrBuzz(int n)</code> method you should add another public method to the Fizzbuzzer:</p><pre><code class="language-csharp">string Count(int n);
// Where n represent the number to count to
// Example, if n = 5 then the output should be
// "1 2 Fizz 4 Buzz"</code></pre><h3>Exercise 3 &mdash; "Sliming"</h3><p>Create a new console project. Once again, we'll build the FizzBuzz application (with the new requirement). Once again, will we use use TDD. However this time we will "slime" every step of implementation.</p><p>Sliming (fake it 'til you make it) is a tactic used as a means to force yourself to ensure high test-coverage. Usually, when we are "writing the minimal code needed, we tend to write "sensible" code (the implementation we actually want). However "sliming" propose we should really write the simplest possible code, no matter how dumb it is.</p><p>Say the goal is to produce the function <code>F(x)=x*x</code>. Then say we write a test, that calls <code>F(2)</code>, and expects (asserts) a return value of <code>4</code>. If we are "sliming", then we write the simplest function we can possibly write to ensure the test is satisfied. So we write the following function:</p><pre><code class="language-csharp">int F(int x){
  return 4;
}</code></pre><p>Unintelligent code indeed. Say we continue by writing a new test, calling <code>F(10)</code>, that expects a return value of <code>100</code>. Since we are sliming, we will change our production code to the following:</p><pre><code class="language-csharp">int F(int x){
  if(x == 2)
    return 4;
  else
    return 100;
}</code></pre><p>Utterly stupid code, and as humans we know this is not even close to the final behaviour we want. However, by doing this process, we are forced to write more (or better) tests. We only stop sliming when it becomes harder than writing the implementation we actually want to write.</p><h3>Contemplation (TDD vs TAD)</h3><p>What are the positives and negatives of TDD? TAD? Write a few sentances (max half-a-page) about your thoughts on these concepts. When are they good to use? Less good? Was sliming helpful? Always? Who are tests for? Is testing useful for only one or many things?</p><h2 id="exercise-2">Exercise 2 &mdash; Debugging via tests</h2><p>You have been provided with code for a class that handles mathematical operations on Matrices. A class which supposedly was written by a really lousy programmer. It does not behave as expected. Your job is to use either TDD or TAD to provide the matrix class with desired behaviour (free from logical errors). Use testing as a means of localizing errors.</p><p>A matrix is a two-dimensional array of elements (in this case numbers). If you are not familiar with matrices, consult (e.g.) Wikipedia to learn how matrix multiplication is performed, and how to calculate the inverse of a 2x2 matrix. Knowledge about matrix operations is vital to write good test cases for this assignment.</p><h2 id="exercise-3">Exercise 3 &mdash; Test coverage </h2><p>You've been provided with a class, simliar to the phone book example discussed in class. Your job is to write tests for this class, attempting to achieve <em>as high test coverage as possible</em>. In a perfect world it will be impossible to introduce errors to the class without any tests failing. This would, in theory, be the highest level of test coverage possible. In practice however it's all about compromise. It's not reasonable to assume that we can maintain a suite of tests that employ full test coverage.</p><p>In this exercise you are expected to modify the code of the given class. However you're <strong>not</strong> allowed to introduce or remove any public methods. Nor to change the signatures of the existing ones.</p><p>When you believe you have achieved a high level of coverage. Grab a friend and let her or him try to make your tests report false-positives. A false-positive is when a test is passing, but the functionality it is supposed to test has actually been broken. It is easy to get snowblind watching your own code so having someone else attempting to ``break'' it is usually a good idea.</p><h3>Contemplation</h3><p>Does full test-coverage ensure perfect code? Write a few sentances (max half-a-page) about your thoughts on the positives and negatives of test-coverage. What is it good for? Not good for? How good is it? When is it relevant? When not? How much <em>can</em> we test? How much <em>should</em> we test? Is there a golden mean? Etc.</p><h2 id="exercise-4">Refactoring</h2><p>Now, it's time to forget about testing (for now) and instead focus on refactoring. The lousy programmer has been at it again. He or she has built a system for a movie rental shop handling customer orders. However, since the lousy programmer was focused on meeting the deadline the code is way more procedural than object oriented.</p><p>The <code>Customer</code> class has a <code>Statement()</code> method, that returns a string of information on a given customers current rentals. However, as a requirement to print the statement as a HTML formatted string just came in, the lousy programmer realized the code is not at all prepared for change.</p><p>Your job is now to refactor the system so that the new method can be implemented without introducing significant duplication.</p><h3>Ideas on what to refactor</h3><p>A good place to start is to have a look at the <code>Statement()</code> method itself. It is way too long! Apart from that, think about the following points:</p><ul><li><b>Method extraction</b> Can some behavior be extracted into a different method?</li><li><b>Replacing case statements</b> Can we use inheritance instead of case statements?</li><li><b>Creation methods</b> Can we use creation methods to make instantiation safer?</li><li><b>Moving behavior</b> Should a given behavior really be defined on another class? A rule-of-thumb is to consider the Law of Demeter, which say that a class should <em>only</em> talk to its closest neighbors. Meaning, it's OK to say: <code>instanceOfSomeClass.Method()</code> But it's not OK to say: <code>instanceOfSomeClass.instanceOfSomeOtherClass.Method()</code></li></ul><h2 id="exercise-5">TDD Practice &mdash; optional</h2><p>Many developers use TDD to "drive" their design forward. Calling it Test Driven Design instead of simply Test Driven Development. Often times we loose focus and end up working on multiple things at once. This is unwanted for many reasons. For example it splits our attention, and cause our (version control) commits to be sprawled.</p><p>On the other hand, many developers find the cost of TDD to be too high in relation to it's payoff. Some disregard testing alltogether. Some disregard the idea of using tests as a way to drive design. In this exercise we'll approach a common programming exercise using the teachings of test driven design, and then reflect upon our findings.</p><p>A ``kata'' is used to practice one's programming skills. Much like musicians practice scales. This exercise asks you to perform, what has come to be known as, the Bowling Game Kata. The bowling game class exposes two public methods. Your job is to implement these bodies TDD-style.</p><p>Remember that this is an exercise in Test Driven Design. So you must follow the <em>red-green-refactor</em>-cycle at all times. And reflect upon the design decisions that you are making as you go along.</p><pre><code class="language-csharp">void Roll(int pins)
// Where pins is the number of pins knocked
// down by the player in this roll
 
int Score()
// Returns the current score at the given time</code></pre><p>The rules of bowling, and consequently the requirements of the game, are outlined below.</p><ul><li>Each game consist of 10 frames (rounds)</li><li>Each frame consist of 2 rolls</li><li>Each roll can knock down 0-10 pins</li><li>The score for the frame is the total number of pins knocked down in that frame + plus bonuses for strikes and spares</li><li>A spare is when the player knocks down all 10 pins in two rolls</li><li>The score of a spare is the number of pins knocked down in the next roll</li><li>A strike is when the player knocks down all 10 pins in the first roll</li><li>The score of a strike is the number of pins knocked down in the next frame</li><li>A frame only consist of one roll if the player rolls a strike</li><li>In the tenth frame the player will have one extra roll <em>if</em> a strike or spare is rolled</li></ul><h3>Contemplation</h3><p>Write a few sentances (max half-a-page) and reflect upon your new won experiences and opinions about using tests as a means to drive design. Does it help? Does it not? Does it enforce good design decisions. Does it enforce bad design decisions? Is it worth it?</p></div><script src="../assets/js/prism.js"></script></body>