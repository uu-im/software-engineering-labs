<!DOCTYPE html><meta charset="utf-8"><html lang="en"><head><title>Block 2</title><link rel="stylesheet" href="../assets/css/main.css"><link rel="stylesheet" href="../assets/css/prism.css"></head></html><body><div class="container"><header><h1>Software Engineering &mdash; Lab 2</h1><p>Spring 2014</p></header><div class="preamble"><p>In this block we'll focus on <em>testing</em> and <em>refactoring</em>. While there are many ways to test code we will focus on <a href="http://en.wikipedia.org/wiki/Unit_testing">unit testing</a>. In essance, unit testing means testing individual functions in isolation. Asserting that some given input yield expected output.</p><p>In regards to testing we'll look at a couple of different aspects of testing. Such as:</p><ul><li>Testing as a means of making sure our code actually does what it's supposed to.</li><li>Testing as a means of discovering, isolating and preventing unnoticed reoccurance of bugs.</li><li>The concept of <em>test coverage</em>, often times called <a href="http://en.wikipedia.org/wiki/Code_coverage">code coverage</a>, as a means of measuring how much of a code base that is covered by tests. An issue <a href="http://martinfowler.com/bliki/TestCoverage.html">open for debate</a>.</li><li>Three different "schools" of testing:<ul><li><a href="http://stackoverflow.com/questions/7199313/what-are-the-pitfalls-of-test-after-development">Test-after development </a>, </li><li> <a href="http://www.extremeprogramming.org/rules/testfirst.html">Test-first development </a>(or more specifically <a href="http://en.wikipedia.org/wiki/Test-driven_development">Test-driven development</a>), and finally</li><li><a href="http://stackoverflow.com/questions/7690238/test-driven-development-initial-implementation">Exceptionally strict test-driven development</a> &mdash; often dubbed "sliming".</li></ul></li></ul><p>Apart from testing, we'll also look at the art of refactoring existing code. Using the classic example <a href="http://www.cs.unc.edu/~stotts/723/refactor/chap1.html">movie rental case</a> by <a href="http://en.wikipedia.org/wiki/Martin_Fowler">Martin Fowler</a>.</p><p><em><strong>Important:</strong> The optional exercise in this block is really optional. There is no requirement to complete at least one optional exercise in this block.</em></p></div><h2>Study material</h2><p>Please do familiarize yourself with the following study material <strong>before</strong> attempting to approach the corresponding lab exercises.</p><h3>Testing</h3><ul><li><a href="https://www.youtube.com/watch?v=QCif_-r8eK4">What is TDD?</a> (~5 min video)</li><li><a href="http://www.youtube.com/watch?v=5gMBGVNR8wE">TDD in Visual Studio using C#</a> (~17 min video)</li><li><a href="https://www.youtube.com/watch?v=xX9hfPkA800">A TDD pair-programming session</a> (~2 h video)</li><li><a href="http://feelings-erased.blogspot.se/2013/03/the-two-main-techniques-in-test-driven.html">"Sliming" / "Fake it 'til you make it"</a> (blog post) </li><li><a href="http://blog.james-carr.org/2006/11/03/tdd-anti-patterns/">TDD anti-patterns</a> (blog post) (i.e. things you should not do)</li></ul><h3>Refactoring</h3><ul><li><a href="http://en.wikipedia.org/wiki/Code_refactoring">What is refactoring?</a> (Wikipedia)</li><li><a href="http://www.cs.unc.edu/~stotts/723/refactor/chap1.html">Refactoring, a first example</a> (A great example of refactoring by Martin Fowler)</li><li>Examples of Martin Fowler's refactoring technique (from his book <a href="http://martinfowler.com/books/refactoring.html">Refactoring &mdash; Improving the design of existing code</a>). Explained by some dude on youtube.<ol><li><a href="https://www.youtube.com/playlist?list=PL3GKSsHsE_qKWl5-XWAX6jACpfId_9-8Y">Composing methods</a> (video playlist)</li><li><a href="https://www.youtube.com/playlist?list=PL3GKSsHsE_qJX-E7GuBkKJ8-BoyiThrk7">Moving Features Between Objects</a> (video playlist)</li><li><a href="https://www.youtube.com/playlist?list=PL3GKSsHsE_qJ54Q3oJ3GNVj8WkFZd6y2y">Organizing data</a> (video playlist)</li><li><a href="https://www.youtube.com/playlist?list=PL3GKSsHsE_qIv4gbun2h268rBc2-RnyNH">Simplifying Conditional Expressions</a> (video playlist)</li><li><a href="https://www.youtube.com/playlist?list=PL3GKSsHsE_qJwgtU88VFGq6cmewrdorxh">Making Method Calls Simpler</a> (video playlist)</li><li><a href="https://www.youtube.com/playlist?list=PL3GKSsHsE_qLVoAoWooC0yk59RLwV4rfW">Dealing With Generalization</a> (video playlist)</li></ol></li></ul><h2>Deliverables</h2><p>This is a summary of the deliverables for this block.</p><h3>Exercise 1 &mdash; <a href="#exercise-1">Introduction to testing</a></h3><p>One Visual Studio solution.</p><ol><li><code>MathUtils</code> (<em>Visual Studio</em> solution)</li></ol><h3>Exercise 2 &mdash; <a href="#exercise-2">Debugging via Tests</a></h3><p>One Visual Studio solution and one text file.</p><ol><li>Matrix (<em>Visual Studio</em> solution)</li><li>Contemplation (Text file in <code>.txt</code>-format)</li></ol><h3>Exercise 3 &mdash; <a href="#exercise-3">Refactoring</a></h3><p>One Visual Studio solution and one text file.</p><ol><li>MovieRental (<em>Visual Studio</em> solution)</li><li>Contemplation (Text-file in <code>.txt</code>-format)</li></ol><h3>Exercise 4 &mdash;<a href="#exercise-4">Test Coverage</a></h3><p>One Visual Studio solution and one diagram.</p><ol><li>PhoneBook (<em>Visual Studio</em> solution)</li><li>Contemplation (Text-file in <code>.txt</code>-format)</li></ol><h3>Exercise 5 &mdash; <a href="#exercise-5">Testing to drive design</a></h3><p>Three Visual Studio projects (preferably in the same solution) and one text file.</p><ol><li>Testing (Visual Studio solution containing the following projects..)</li><ol><li>TAD (<em>Visual Studio</em> project) </li><li>TDD (<em>Visual Studio</em> project)</li><li>Sliming (visual Studio project)</li></ol><li>Contemplation (text document in <code>.txt</code> format)</li></ol><h3>Exercise 6 &mdash; <a href="#exercise-6">TDD Practice</a> (optional)</h3><p>One Visual Studio solution and one text file.</p><ol><li>BowlingGameKata (<em>Visual Studio</em> solution)</li><li>Contemplation (Text-file in <code>.txt</code>-format)</li></ol><h2 id="exercise-1">Exercise 1 &mdash; Introduction to testing</h2><p>In this exercise we're going to familiarize ourselves with the concept of unit testing.</p><ol><li>Create a new Visual Studio Solution.</li><li>Add a new <code>Class Library</code> project, and name it <code>MathLibrary</code>.</li><li>Add a new <code>Unit Test Project</code> and name it <code>MathLibraryTests</code></li><li>Create a new class in your <code>MathLibrary</code> project. Name it <code>MathLib.cs</code>.</li><li>Copy the contents of the  <a href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/MathLibrary/MathLibrary/MathLib.cs"><code>MathLib</code> example class</a> and paste it into your class file.</li><li>Create a new class in your <code>MathLibraryTests</code> project. Name it <code>MathLibTests</code>.</li><li>Copy the contents of the <a href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/MathLibrary/TestProject/MathLibraryTests.cs"><code>MathLibTests</code> example class</a> and paste it into your class file.</li><li>Add a reference (via <code>Solution Explorer</code>) to the <code>MathLibrary</code> project in the <code>MathLibraryTests</code> project. We do this because the test project is going to test classes in the <code>MathLibrary</code> project.</li></ol><p>So, if you've set up your solution according to the above, then we are ready to rock. The <code>MathLib</code> project contain a bunch of public static methods that does some math related stuff.</p><p>If you take a closer look at the <code>MathLib</code> class you'll notice that not all methods are fully implemented. If you take a closer look at the <code>MathLibTests</code> class you'll notice that not all tests are fully implemented. However you've been given the outline. </p><p>In this exercise you should not add or remove any public methods or tests. Your job is to:</p><ol><li>Complete the implementation of each method in the <code>MathLib</code> class.</li><li>Complete the implementation of each test method in the <code>MathLibTests</code> class.</li></ol><p>Remember to continuously run your tests. And remember that tests without implementation report "false positives". Meaning that tests without implementation are listed as "passing" tests. </p><h2 id="exercise-2">Exercise 2 &mdash; Debugging via tests</h2><p>In this exercise we're going to explore the idea of using tests as a means of locating bugs.</p><p>Start off by <a href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/MatrixUtils/MatrixUtils/Matrix.cs">downloading this <code>Matrix</code> class</a>. Supposedly, it was written by a really lousy programmer. And consequently it contains a bunch of bugs. More specifically a bunch of logical errors.</p><p>Create a new solution. Add in the <code>Matrix</code> class. And create a test project.</p><p>Your job is to eliminate all bugs in the <code>Matrix</code> class. You must do this by introducing test cases that will help you determine where the errors actually reside.</p><p><em>A matrix is a two-dimensional array of elements (in this case numbers). If you are not familiar with matrices, consult (e.g.) Wikipedia to learn how (e.g.) matrix multiplication is performed, and how to calculate the inverse of a 2x2 matrix. Some knowledge about matrix operations is vital, in being able to write good test cases for the class.</em></p><h2 id="exercise-3">Exercise 3 &mdash; Refactoring</h2><p>Now we're going to focus on refactoring. The process of rewriting existing code without changing it's functionality. Increasing readability and decreasing complexity.</p><p>The lousy programmer has been at it again. He/she has built a system for a movie rental shop handling customer orders. However, since the lousy programmer was focused on meeting the deadline the code is way more procedural than object oriented. Truth be told, the code you'll be given in this exercise is actually a classic example by author <a href="http://en.wikipedia.org/wiki/Martin_Fowler">Martin Fowler</a>.</p><p>First off, create a new <code>Console Application</code> in Visual Studio. Then download and copy in the contents of the following classes into your project.</p><ul><li><a href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/MovieRentalRefactoring/MovieRentalBefore/Customer.cs">Customer.cs</a></li><li><a href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/MovieRentalRefactoring/MovieRentalBefore/DVD.cs">DVD.cs</a></li><li><a href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/MovieRentalRefactoring/MovieRentalBefore/DomainObject.cs">DomainObject.cs</a></li><li><a href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/MovieRentalRefactoring/MovieRentalBefore/Movie.cs">Movie.cs</a></li><li><a href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/MovieRentalRefactoring/MovieRentalBefore/Rental.cs">Rental.cs</a></li><li><a href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/MovieRentalRefactoring/MovieRentalBefore/Program.cs">Program.cs</a> (main program file)</li></ul><p>The <code>Customer</code> class has a <code>Statement()</code> method, that returns a string of information on a given customers current rentals. However, as a requirement to print the statement as a HTML formatted string just came in, the lousy programmer realized the code is not at all prepared for change. Because of the code's procedural nature, meeting the new requirements will be painful.</p><p>Your job is now to...</p><ol><li>Refactor the whole project. Aiming for high readability, and low complexity. Avoiding duplication and increasing flexibility. Stop only when you find no more ways of refactoring to the better!</li><li>And then implement the <code>HtmlStatement</code> method.</li></ol><p>To let you refactor with confidence, make sure you <a href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/MovieRentalRefactoring/MovieRentalTests/CustomerIntegrationTests.cs">download this class containing an integration test</a> for the <code>Statement</code> method. It also contains a test for the <code>HtmlStatement</code> method, however commented out. Make sure you uncomment that test when you begin working on the <code>HtmlStatement</code> method.</p><p>So, what to refactor? A good place to start is to have a look at the <code>Statement()</code> method itself. It is way too long! Apart from that, think about the following points:</p><ul><li><b>Method extraction</b> Can some behavior be extracted into a different method?</li><li><b>Replacing case statements</b> Can we use inheritance instead of case statements?</li><li><b>Creation methods</b> Can we use creation methods to make instantiation safer?</li><li><b>Moving behavior</b> Should a given behavior really be defined on another class? A rule-of-thumb is to consider the Law of Demeter, which say that a class should <em>only</em> talk to its closest neighbors. Meaning, it's OK to say: <code>instanceOfSomeClass.Method()</code> But it's not OK to say: <code>instanceOfSomeClass.instanceOfSomeOtherClass.Method()</code></li></ul><p>If you want a narrative that "talks you through" the refactoring process. It's highly recommended to check out <a href="http://www.cs.unc.edu/~stotts/723/refactor/chap1.html">Martin Fowler's step-by-step approach</a> to refactoring this particular system. The code is written in Java but you'll have no trouble translating it to C#.</p><h3>Contemplation</h3><p>Write a few sentances (max half-a-page) about your on the design improvements if your code. Which techniques did you use? Which ones not? Why? When are they suitable? etc.</p><h2 id="exercise-4">Exercise 4 &mdash; Test coverage </h2><p>In this exercise we're going to attempt to achieve the mythical notion of <em>full test coverage</em></p><p>Start off by <a href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/PhoneBook/PhoneBook/PhoneBook.cs">downloading the <code>PhoneBook</code> class</a>. It's very similar to the one you've been working with before.</p><p>Study the class and contemplate the details of what it does. What are the quirks? Think in terms of expected output in relation to varying input.</p><p>In a perfect world, we would write tests untill we achieve full test coverage. In a perfect world it will then be <strong>impossible</strong> to introduce errors to the class without any tests failing. This is, in theory, the highest possible level of test coverage.</p><p>In practice however it's all about compromise. It's not reasonable to assume that we can maintain a suite of tests that employ full test coverage.</p><p>Your job is consequently to create a test suite for the <code>PhoneBook</code> class. Aiming for as high test coverage as possible. You are of course allowed to refactor the <code>PhoneBook</code> class, to make it easier for you to handle.</p><p>When you believe you have achieved a high level of coverage. Grab a friend and let her or him try to make your tests report <em>false-positives</em>. A <em>false-positive</em> is when a test is passing, but the functionality it is supposed to test actually is broken. It's easy to get "snowblind" stairing at your own code so having someone else attempting to "break" it, is usually a good idea.</p><h3>Contemplation</h3><p>Does full test-coverage ensure perfect code? Is full test coverage possible? What is it good for? Not good for? How good is it? When is it relevant? When not? How much <em>can</em> we test? How much <em>should</em> we test? Is there a golden mean? Etc. Write a few sentances (max half-a-page) about your thoughts on the positives and negatives of test-coverage.</p><h2 id="exercise-5">Exercise 5 &mdash; Testing to drive design</h2><p>In this exercise we're going to build more or less the same application (a little thing called <code>FizzBuzz</code>) three times. But each time we'll use a different approach. Namely three different approaches to testing.</p><p>Below, three project specifications follow. Create all three as separate projects in the same <em>Visual Studio</em> solution. Name the projects as follows:</p><ol><li><code>FizzBuzzTAD</code></li><li><code>FizzBuzzTDD</code></li><li><code>FizzBuzzSliming</code></li></ol><p>Also, you'll need to create a test project. For the sake of this project it's ok to keep all of your tests in one test project. However, you must put the tests in separate classes. Like so:<ol><li><code>FizzBuzzTADTests.cs</code></li><li><code>FizzBuzzTDDTests.cs</code></li><li><code>FizzBuzzSlimingTests.cs</code></li></ol></p><p>... or similarly.</p><p>The rules of the game of FizzBuzz reads as follows:</p><ul><li><code>Fizz</code> is returned, when given a number divisible by 3</li><li><code>Buzz</code> is returned, when given a number divisible by 5</li><li><code>FizzBuzz</code> is returned, when given a number divisible by 3 <strong>and</strong> 5</li><li>The input number itself is returned, when given an input number not divisible by 3 <strong>nor</strong> 5</li></ul><h3>5.1 Test-after development (TAD)</h3><p>Create a new console project. Add a class called <code>FizzBuzz.cs</code>, and give it a public static method like so:</p><pre><code class="language-csharp">class FizzBuzz{
    public static string FizzOrBuzz(int n)
    {
        // returns "Fizz" if divisible by 3
        // returns "Buzz" if divisible by 5
        // returns "FizzBuzz" if divisible by 3 and 5
    }
}</code></pre><p>Your job is now to...</p><ol><li>Implement the body of the <code>FizzOrBuzz(int n)</code> function, so that it behaves according to specification.</li><p>And when you're done. Then..</p><li>Create a test project and write suitable tests that will ensure reasonable test coverage of the method.</li></ol><p>When you're done. Stop for a minute and consider how much code coverage you've achieved. Is it enough? Is it really hard to introduce errors without having tests that fail? Keep this question in mind as you move on to the next exercise.</p><h3>5.2 Test-driven development (TDD)</h3><p>We're now going to build the FizzBuzz application again, but this time through test-driven development (TDD). Create a new console project.</p><p>Remember, that we are now developing software according to the rules of TDD. This means that we at all times must follow the steps below.</p><ol><li>Introduce a (or change an existing) test.</li><li>Watch the test fail (for the right reason).</li><li>Write the minimal code needed to make it pass.</li></ol><p>An easy way to remember the above steps is to think of the idiom <a href="http://en.wikipedia.org/wiki/Test-driven_development">red-green-refactor</a>. In essence the idea is we start by producing a state where we have a test that fails (red). Then we write enough code to make it pass (green). Only then, are we allowed to refactor code. When done we restart, by introducing another failing test.</p><p>This time we have some new requirements though. Another public static method must be added to the FizzBuzzer:</p><pre><code class="language-csharp">public static string Count(int n){
  // FizzBuzz from 1 all the way up to n.
  // Example, if n = 5, then
  // return "1 2 Fizz 4 Buzz"
}</code></pre><h3>5.3 "Sliming"</h3><p>Once again, we'll build the FizzBuzz application (with the new <code>Count(int n)</code>requirement). Once again, will we use use TDD. However this time we will "slime" every step of implementation. Start by creating a new console project.</p><p>Sliming (fake it 'til you make it) is a tactic used as a means to force yourself to ensure high test-coverage. Usually, when we are "writing the minimal code needed, we tend to write "sensible" code (the implementation we actually want). However "sliming" propose we indeed really should write the simplest possible code, no matter how dumb it is.</p><p>Say the goal is to produce a function such that <code>F(x)=x*x</code>. So we start by writing a test, that calls <code>F(2)</code>, and expects (asserts) a return value of <code>4</code>. If we are "sliming", then we write the simplest function we can possibly write to ensure the test is satisfied. So we write the following function:</p><pre><code class="language-csharp">int F(int x){
  return 4;
}</code></pre><p>Unintelligent code indeed. Say we continue by writing a new test, calling <code>F(10)</code>, that expects a return value of <code>100</code>. Since we are sliming, we will change our production code to the following:</p><pre><code class="language-csharp">int F(int x){
  if(x == 2)
    return 4;
  else
    return 100;
}</code></pre><p>Utterly stupid code, and as humans we know this is not even close to the final behaviour we want. However, by doing this process, we are forced to write more (or better) tests. We only stop sliming when it becomes harder than writing the implementation we actually want to write.</p><p>Your job is again to implement another version of the FizzBuzzer. If the above concepts however seem unfamiliar to you. Consult the reading material before you proceed.</p><h3>Contemplation (TAD, TDD and Sliming)</h3><p>What are the positives and negatives of TDD? TAD? Sliming? Write a few sentances (max half-a-page) about your thoughts on these concepts. When are they good to use? Less good? Was sliming helpful? Always? Never? Somwhat? Who are tests for? Is testing useful for only one or many things? What? Why? Does testing first improve design? If yes, in what way? If no, how come many claim that is the case?</p><h2 id="exercise-6">Exercise 6 &mdash; TDD Practice &mdash; optional</h2><p>Many developers use TDD to "drive" their design forward. Calling it Test Driven Design instead of simply Test Driven Development. Often times we loose focus and end up working on multiple things at once. This is unwanted for many reasons. For example it splits our attention, and cause our (version control) commits to be sprawled.</p><p>On the other hand, many developers find the cost of TDD to be too high in relation to it's payoff. Some disregard testing alltogether. Some disregard the idea of using tests as a way to drive design. In this exercise we'll approach a common programming exercise using the teachings of test driven design, and then reflect upon our findings.</p><p>A ``kata'' is used to practice one's programming skills. Much like musicians practice scales. This exercise asks you to perform, what has come to be known as, the Bowling Game Kata. The bowling game class exposes two public methods. Your job is to implement these bodies TDD-style.</p><p>Remember that this is an exercise in Test Driven Design. So you must follow the <em>red-green-refactor</em>-cycle at all times. And reflect upon the design decisions that you are making as you go along.</p><pre><code class="language-csharp">void Roll(int pins)
// Where pins is the number of pins knocked
// down by the player in this roll
 
int Score()
// Returns the current score at the given time</code></pre><p>The rules of bowling, and consequently the requirements of the game, are outlined below.</p><ul><li>Each game consist of 10 frames (rounds)</li><li>Each frame consist of 2 rolls</li><li>Each roll can knock down 0-10 pins</li><li>The score for the frame is the total number of pins knocked down in that frame + plus bonuses for strikes and spares</li><li>A spare is when the player knocks down all 10 pins in two rolls</li><li>The score of a spare is the number of pins knocked down in the next roll</li><li>A strike is when the player knocks down all 10 pins in the first roll</li><li>The score of a strike is the number of pins knocked down in the next frame</li><li>A frame only consist of one roll if the player rolls a strike</li><li>In the tenth frame the player will have one extra roll <em>if</em> a strike or spare is rolled</li></ul><h3>Contemplation</h3><p>Write a few sentances (max half-a-page) and reflect upon your new won experiences and opinions about using tests as a means to drive design. Does it help? Does it not? Does it enforce good design decisions. Does it enforce bad design decisions? Is it worth it?</p></div><script src="../assets/js/prism.js"></script></body>