<!DOCTYPE html><meta charset="utf-8"><html lang="en"><head><title>Block 4</title><link rel="stylesheet" href="../assets/css/main.css"><link rel="stylesheet" href="../assets/css/prism.css"><link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css"></head></html><body><div class="container"><header><h1>Software Engineering &mdash; Lab 4</h1></header><div class="preamble"><p>Using code contracts we're now going to see how we can "guard" behavior and state. And also how to ensure that subclasses respect the restrictions set by their superclass.</p></div><h2>Study material</h2><p>Please do familiarize yourself with (as much as you find necessary of) the following study material before attempting to approach the corresponding lab exercises. Naturally, all of the study material is not mandatory. But in relation to the labs, you will benefit greatly from exploring it.</p><ul><li><a href="http://research.microsoft.com/en-us/projects/contracts/userdoc.pdf">Code Contracts user manual &mdash; Microsoft Research</a></li><li><a href="http://www.youtube.com/watch?v=xVhQ9yfo54I">.NET Code Contracts</a> (~ 27 min video)</li></ul><h2>Deliverables</h2><p>This is a summary of the deliverables for this block.</p><h3>Exercise 1 &mdash;  <a href="#exercise-1">Veichles</a></h3><p>One Visual Studio solution</p><h2 id="exercise-1">1 &mdash; State-space, behavior and Code Contracts</h2><p>In class you've discussed an example with vehicles with different weights. We're going to implement that example and attempt to enforce behaviour and state-space through the use of contracts. Let's start off with some basic classes:</p><pre><code class="language-csharp">class RoadVehicle
{
    public double Weight { get; protected set; }
 
    public RoadVehicle() { }
    public RoadVehicle(double weight)
    {
        if (0.5 > weight || weight > 10.0)
            throw new ArgumentException();
 
        Weight = weight;
    }
}
 
class Automobile : RoadVehicle
{
    public Automobile(double weight)
    {
        if (0.2 > weight || weight > 13.0)
            throw new ArgumentException();
        
        Weight = weight;
    }
}      </code></pre><p> Think back to class, and try to realize the problem of the above code. Hint: the subclass ignores the restrictions posed by the superclass's constructor by simply not calling it. A mistake of bad design, perhaps, but an easy mistake to make.</p><h3>Setting up Visual Studio to use Code Contracts</h3><p>To enable Visual Studios static and runtime contract checking, right-click your project in the <em>Solution Explorer</em> and choose </em>Properties</em>. Select the <em>Code Contracts</em> tab  and make sure to check <em>Perform Runtime Contract Checking</em>, <em>Perform Static Contract Checking</em> and also to set the <em>Warning Level</em> to <em>High</em>. Save the configuration file.</p><p>Whenever you now build the project, the <em>Background contract analysis</em> will be run, and you can track its progress in the <em>Output</em>-pane.</p><h3>Using invariants to enforce the weight</h3><p>Now, let's make use of invariants instead of exceptions as to force any subclass to follow the restrictions on weight. Add the following method to the RoadVehicle class:</p><pre><code class="language-csharp">/* RoadVehicle */
[ContractInvariantMethod]
private void ObjectInvariant()
{
    Contract.Invariant(0.5 < Weight && Weight < 10.0);
}</code></pre><p>Invariants in C# are added through creating a (void-returning) private method that is decorated with <em>[ContractInvariantMethod]</em>. The method must never be called from anywhere by the user code.</p><h4>Repeat for the Automobile class</h4><p>Do the same thing for the Automobile class but using the weight restrictions of the automobile.</p><h4>Remove the manual exception throws</h4><p>Since we're moving over to using invariants. Remember to <em>remove</em> the now unnecessary <em>ArgumentException</em> checks.</p><h4>Build the project</h4><p>If you've progressed correctly, build the project, and then wait a couple of minutes for the static checker to run. You'll notice a couple of "squigglies" show up -- indicating paths that will lead to erroneous states. What are the states and why do they happen? Discuss with a partner.</p><p>Eliminate the errors through (1) removing the parameter-free constructor in the base class, and (2) calling the base constructor with a parameter from the subclass's constructor. As follows:</p><pre><code class="language-csharp">class RoadVehicle
{
    public double Weight { get; protected set; }
 
    public RoadVehicle(double weight)
    {
        Weight = weight;
    }
    ...
}
 
class Automobile : RoadVehicle
{
    public Automobile(double weight) : base(weight) 
    { }
    ...
}</code></pre><p>The project should now be free of static errors, and we have increased the level of "correctness" in the code as it is now significantly difficult to create a subclass that breaks the invariant rules of the superclass.</p><p>Let's have a look at how code contracts can help us realize there are problems with our code. There is still a major problem with our code, and we will find it when we try instantiating an automobile with edge case weight. Put the following code in the main entry point of the application, run the program and take note of the exception that arise.</p><pre><code class="language-csharp">Automobile car = new Automobile(12.0);</code></pre><p>We should now realize that the conceptual problem with our code is that we're actually violating Liskov's substitution principle. Discuss with a partner why that is.</p><h3>Rethinking the automobile class</h3><p>Now that we've realized that an automobile cannot possible be a ground vehicle if the weight of the automobile is greater than the maximum allowed weight for anything that is a ground vehicle, let's rethink. Instead, rewrite the invariant of the automobile so that the invariant enforce:</p><pre><code class="language-csharp">1 < Weight && Weight < 7.5</code></pre><h3>Pre- and post-conditions</h3><p>Now, we'll leave the invariants and talk about pre- and post-conditions. Let's introduce the concept of passengers to the automobile class. Implement the following method and it's required members:</p><pre><code class="language-csharp">/* Automobile */
public void SetPassengers(int n)
{
  if (n > 5)
    throw new ArgumentException("Could not fit all passengers");
 
  _currentPassengers = n;
}</code></pre><h4>Pre-</h4><p>Let's replace the exception-throwing code above with a pre-condition. You can think of pre-conditions as a way to make sure that a method is only allowed to be called with valid input. Rewrite the method like so:</p><pre><code class="language-csharp">public void SetPassengers(int n)
{
  Contract.Requires(n <= 5);
  _currentPassengers = n;
}</code></pre><p>Now, to test whether or not this works, put the following code in the main entry of the application:</p><pre><code class="language-csharp">Automobile am = new Automobile(4);
am.SetPassengers(2); // Should be ok
am.SetPassengers(6); // Should not be ok</code></pre><p>Rebuild the project and notice the errors that the static checker finds. Now we need not even run the application before the checker realize our mistakes.</p><p>Experiment with how the static checker behaves when we are using variables instead of primitives. Use a variables instead of a hard-coded number.</p><h4>Post-</h4><p>Now let's instead focus on post-conditions. Quite intuitively, if pre-conditions ensure correctness of state upon entry in a method, post-conditions ensure correctness of state upon exit out of a method. Using post-conditions it is often possible to mathematically and specifically describe what the method "actually do". To write post-conditions we use the ensures-method:</p><pre><code class="language-csharp">Contract.Ensures(statement);
// Where the statement evaluates to true or false</code></pre><p>Write a post-condition that enforce the implementation of the SetPassenger-method. Run the application to see if your post-condition passes. To verify that you've written a correct post-condition, "break" the code by changing the implementation to an incorrect one, such as:</p><pre><code class="language-csharp">_currentPassengers = n + 1;</code></pre><h3>Extend the classes</h3><p>If you've completed all of the above. Think of some new behavior that could be added to either the sub- and/or the superclass. Implement that behavior and then write invariants, pre- and/or post-conditions to "protect" it.</p></div><script src="../assets/js/prism.js"></script><script src="http://code.jquery.com/jquery-2.1.3.min.js"></script><script src="../assets/js/main.js"></script></body>