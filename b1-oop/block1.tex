\documentclass{article}
\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{hyperref}




% terminal code styling
% invoke using \begin{lstlisting}[style=terminal]
\lstdefinestyle{terminal}{
  basicstyle=\color{white}\ttfamily,
  keywordstyle=\color{white},
  numberstyle=\color{white},
  commentstyle=\color{white},
  stringstyle=\color{white},
  backgroundcolor=\color[rgb]{.1,.1,.1},
}

% csharp code styling
% (as default to save typing)
\lstset{
  language=[Sharp]C,
  basicstyle=\color[rgb]{0.3,0.3,0.3}\ttfamily,
  keywordstyle=\color[rgb]{0,0.5,0.5},
  numberstyle=\color[rgb]{0.7,0.7,0.7},
  commentstyle=\color[rgb]{0.1,0.5,0.1},
  stringstyle=\color[rgb]{0.6,0.1,0.5},
  backgroundcolor=\color[rgb]{0.95,0.95,0.95},
  showstringspaces=false
}

% steps
\newcounter{stepcounter}
\setcounter{stepcounter}{0}
\newenvironment{steps}{ 
  \begin{enumerate}[label=\color{red}Step \theenumi)]
    \setcounter{enumi}{\value{stepcounter}}
}{
  \setcounter{stepcounter}{\value{enumi}}
  \end{enumerate}
}

% hrefs
\hypersetup{
  colorlinks=true,
  urlcolor=cyan
}


\begin{document}

  \title{ Software Engineering | Lab 1 }
  \author{ Uppsala University }
  \date{ Spring 2014 }
  \maketitle

  \lstset{language=[Sharp]C}







\section*{ Introduction }
In this first block we’ll refresh our object oriented skills and dive into concepts such as constructors, public and private membership, interfaces and inheritance as well as a couple of more technical features such as threads and GUI’s.










\pagebreak
\section{ A Simple Ticket Machine }
The purpose of this first exercise is simply to get up to speed. Familiarize ourselves with the C\# language, Visual studio environment and refresh our knowledge in object oriented programming.

In this exercise we’re building a very simple ticket machine. You can think of the ticket machine as an automated ticket machine at the cinemas. You insert money, press ok, and get a ticket.


\subsection{An interface for the ticket machine}
Naturally we'll build thins ticket machine as a class. The class will be called \texttt{TicketMachine} and it will contain a number of public methods. Let's describe the class using a \texttt{C\# interface}.

\begin{lstlisting}
interface ITicketMachine {
  string InsertMoney(int amount);
  string ShowPrice();
  string ShowBalance();
  string RefundMoney();
  string PrintTicket();
}
\end{lstlisting}
\begin{steps}
\item Open up \texttt{Visual Studio} and create a new \texttt{C\#} solution. Make sure you choose \texttt{C\#} as the language, and not \texttt{Visual Basic} or any other language.
\item Add a new interface file to your project. Call it \texttt{ITicketMachine} and save it as \texttt{ITicketMachine.cs}.
\item Make sure your interface looks like the code example above.
\end{steps}





\subsection{Implementing the interface}
Let’s create the actual class. The ticket machine that will implement the interace.
\begin{steps}
\item Create a new class called \texttt{TicketMachine.cs} and tell it to implement the interface we just created. Like so:
\end{steps}
\begin{lstlisting}
class TicketMachine : ITicketMachine
{
}
\end{lstlisting}
\begin{steps}
\item Build the project (by pressing \texttt{F5}) and contemplate why it won't build.
\end{steps}
To make sure the application will build. Let's actually implement the members of the interface in the concrete ticket machine class.
\begin{steps}
\item Open the concrete ticket machine class and right-click the name of the interface in the class definition. Then select \texttt{Implement Interface > Implement Interface}. Or simply implement all of the members of the interface manually.
\end{steps}
\begin{lstlisting}
class TestMachine : ITicketMachine
{
  public string InsertMoney(int amount){
    throw new NotImplementedException();
  }
  public string ShowBalance(){
    throw new NotImplementedException();
  }
  public string ShowPrice(){
    throw new NotImplementedException();
  }
  public string RefundMoney(){
    throw new NotImplementedException();
  }
  public string PrintTicket(){
    throw new NotImplementedException();
  }
}
\end{lstlisting}
Superb! Now we, at least, have an application that builds.


\subsection{Command line interface}
So, now we have the ``shell'' for a class that will act as the ticket machine. But we need a way to interact with the ticket machine. I.e. we need a class that will use the ticket machine class.

For the sake of simplicity you've been provided with a command line interface (CLI) class that you can \href{https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/b1-oop/code/TicketMachine/TicketMachine/TicketMachineInteractor.cs}{download here}.

In your main \texttt{Program.cs} class you can then interact with the \texttt{TicketMachineInteractor} like so:

\begin{lstlisting}
class Program{
  public static void Main(){
    // Instantiate a ticket machine
    ITicketMachine tm = new TicketMachine();

    // Instantiate an interactor, and pass in the ticket machine
    TicketMachineInteractor interactor = new TicketMachineInteractor(tm);

    // Start the interactor
    interactor.Start();
  }
}
\end{lstlisting}

Ok, let’s now create a CLI so that we can interact with our TicketMachine class. You should already have a file called Program.cs. Copy and paste the following code into this file. Have a look at the contents of this code and discuss it with a lab partner.

\begin{steps}
\item Try running your application!
\end{steps}
The output should be similar to this:

\begin{lstlisting}[style=terminal]
 (q) Quit
 (i) Insert money
 (b) Show balance
 (p) Show price
 (r) Refund money
 (t) Print ticket
 ==============================================
 Choose action (h for help)
 >
\end{lstlisting}
If you, when running your application, do make one of the choices above -- of course a \texttt{NotImplementedException} will be thrown because that's all our concerete Ticket Machine does for now.




\subsection{Ticket Machine ticket costs}
Before we get into implementing the body of each method in the concrete ticket machine class -- let's declare a constructor. The constructor will take an integer as an argument. The integer represents the price of a single ticket. Consequently, our constructor needs to save the value passed in, as an instance variable so that we can use it later on. We need it to  Let's do it:
\begin{steps}
\item Implement a constructor in the ticket machine class, that takes an integer as an argument, and saves that value to an instance variable.
\end{steps}
\begin{lstlisting}
class TicketMachine : ITicketMachine{
  private int price;

  public TicketMachine (int ticketCost){
    this.price = ticketCost;
  }
}
\end{lstlisting}



\subsection{Full implementation}
Now it's time to actually implement the members of the concrete ticket machine class. Below you'll find a runtime example of what a session with the ticket machine could look like.
\begin{lstlisting}[style=terminal]
 Choose action (h for help)
 >   i
 >>> Enter the amount you wish to insert (SEK):
 >   50
 >>> Inserted 50 kr
 ==============================================
 Choose action (h for help)
 >   t
 >>> Insufficient funds.. Missing 150 kr
 ==============================================
 Choose action (h for help)
 >   p
 >>> The price of one ticket is 200 kr
 ==============================================
 Choose action (h for help)
 >   i
 >>> Enter the amount you wish to insert (SEK):
 >   175
 >>> Inserted 175 kr
 ==============================================
 Choose action (h for help)
 >   t
 >>> Printing ticket....
 ==============================================
 Choose action (h for help)
 >   b
 >>> Your balance is currently: 25 kr
 ==============================================
 Choose action (h for help)
 >   i
 >>> Enter the amount you wish to insert (SEK):
 >   75
 >>> Inserted 75 kr
 ==============================================
 Choose action (h for help)
 >   r
 >>> Refunding 100 kr
 ==============================================
 Choose action (h for help)
 >
\end{lstlisting}
If you find the runtime example above too confusing -- there's some comments below explaining what each method should do. Please note: all the methods return strings that will be printed by the interactor.

\begin{lstlisting}
public string InsertMoney(int amount){
  // update the current balance as defined by amount
  // only if amount is greater than 0
  // return string that explains what happened
}
public string ShowBalance(){
  // return a string that describes the current balance
}
public string ShowPrice(){
  // return a string that describes the price of a ticket
}
public string PrintTicket(){
  // if balance is enough
  //    reduce balance accordingly, and
  //    return string describing ticket
  // if balance is not enough
  //    return error message and amount missing
}
public string RefundMoney(){
  // print the amount of money refunded
  // reset the current amount and print it
}
\end{lstlisting}
Consequently the last task of this exercise is to...
\begin{steps}
\item Implement the intended functionality of all the \texttt{ITicketMachine} members in the concrete \texttt{TicketMachine}.
\end{steps}














\pagebreak
\section{More Ticket Machines}
So your ticket machine is fully functional. Yay, celebrate! However, let’s now look at how much abstraction we've achieved with our current implementation of the ticket machine. Does our ticket machine allow different prices, or other payment schemes?

Naturally we can change the ticket price at \textbf{compile time}:
\begin{lstlisting}
public static void Main ()
{ 
  ITicketMachine cheap = new TicketMachine (1020);
  ITicketMachine expensive = new TicketMachine(40500);
...
\end{lstlisting}
And naturally we can of course alter the price at \textbf{runtime}, by for example allowing the user to specifiy the price of a ticket:
\begin{lstlisting}
public static void Main ()
{ 
  Console.Write("Specify how much a ticket is in SEK and press enter");
  int price = Int32.Parse(Console.ReadLine());
  ITicketMachine tm = new TicketMachine (price);
...
\end{lstlisting}
But there's one thing we haven't really talked about yet. The power of programming towards interfaces. Our ticket machine is actually way more abstract than one might first imagine. Take note of the fact that the \texttt{TicketMachineInteractor} class does \textbf{not} accept a \texttt{TicketMachine}, but rather an \texttt{ITicketMachine}. This means that it can an instance of any class as long as that class implements the \texttt{ITicketMachine} interface.



\subsection{Donation Machine}
Let's build a new ticket machine that also implements the \texttt{ITicketMachine} interface, but exhibits different behaviour.
\begin{steps}
\item Create the file \texttt{DonationMachine.cs} and let it contain the class definition that implements the interface \texttt{ITicketMachine}.
\item Implement the body of the members, according to the specification below.
\end{steps}
The pseudo-code below explains what the donation machine does.
\begin{lstlisting}
public class DonationMachine : ITicketMachine{
  public string InsertMoney(int amount){
    // update the current balance as defined by amount
    // only if amount is greater than 0
    // return string that explains what happened
  }
  public string ShowBalance (){
    // return a string that describes the current balance
  }
  public string ShowPrice (){
    // return a string that describes the minimum donation
  }
  public string PrintTicket (){
    // if balance is greater than minimum donation
    //    commit donation by
    //      - update total balance with current balance
    //      - reset current balance
    //      - print total balance
    // else
    //    return error message and amount missing
  }
  public string RefundMoney (){
    // print the amount of money refunded
    // reset the current balance
  }
}
\end{lstlisting}
Now we can see why programming towards interfaces is such a powerful idea. Instantiate and send a \texttt{DonationMachine} to the \texttt{TicketMachineInteractor} instead.
\begin{lstlisting}
class Program{
  public static void Main(){
    ITicketMachine tm = new DonationMachine(10);
    TicketMachineInteractor interactor = new TicketMachineInteractor(tm);
    interactor.Start();
  }
}
\end{lstlisting}
\begin{steps}
\item Run the application! And consider how we didn't have to make any modifications to the \texttt{TicketMachineInteractor} class.
\end{steps}
Because the \texttt{TicketMachineInteractor} class is prpgrammed towards an interface rather than an implementation -- it is fully functional with whatever implementation we choose to build, so long as the implementation implements the \texttt{ITicketMachine} interface.





\subsection{Parking Machine}
While we're at it, let's create another machine. A regular 'ol Swedish parking machine.

\begin{steps}
\item Create a new class called \texttt{ParkingMachine} and let it implement the \texttt{ITicketMachine} interface. It's implementation should follow the specification below.
\end{steps}
\begin{itemize}
  \item The price is the value of 10 minutes of parking.
  \item The price should (as in the other machines) be set via the constructor.
  \item When the user asks for a ticket the ticket must show how many minutes of parking the user receives.
  \item Parking time can only be in full multiplications of 10 minutes, the rest the user will receive as change.
  \item So, if the price of a ticket is 5 SEK, and the user inserts 13 SEK, the parking time would be 20 minutes, and the change 3 SEK.
\end{itemize}



\subsection{Wrap up}
Consider again the power of interfaces. While the above examples might be slightly contrived, take a minute to consider the implications of adding a class such as the one below.
\begin{lstlisting}
public class ExternalTicketMachine : ITicketMachine
{ 
  private int price, balance;

  public ExternalTicketMachine ()
  {
    this.price = // make a web request to get the price of a ticket
    this.balance = 0;
  }
  public string InsertMoney(int amount){
    // increase current balance locally
  }
  public string ShowBalance(){
    // return current balance locally
  }
  public string ShowPrice(){
    // make a web request to get the price of a ticket
  }
  public string PrintTicket(){
    // make a web request to an external service
    // sending some user details and the current balance
    // returning the ticket recieved by the web request call
  }
  public string RefundMoney(){
    // refund money locally
  }
}
\end{lstlisting}
When we are programming to interfaces we are more prepared for change.














\pagebreak
\section{Basic GUI coding and Event Handling}
In this assignment, you should build a basic desktop application using Microsoft Visual Studio. The assignment should be solved using the programming language C\#.NET. The course literature McConnell (2009) primarily shows code examples in VB.NET and C++. It is up to you to and good C\# tutorials on Internet.
\begin{enumerate}
  \item The application should be a windows application consisting of one form. On that form, place one multiple-row textbox component, one listbox with dummy content (e.g. \texttt{"line1"}, \texttt{"line2"} et cetera) and one single-row textbox component. When something is written in the single-line textbox and \texttt{ENTER} is pressed, you should take the selected value from the listbox (e.g. \texttt{"line 1"}, 14 merge it with \texttt{" : "} and the content of the single-row textbox. Then you should add the result string to the multiple-row textbox.
  \item Add a button on the form with the text \texttt{"Store message"}. When the button is clicked, the content of both text boxes should be cleared.
  \item Add another button on the form with the text \texttt{"Start simulation"}. When the button is pressed, you should start a new thread. We will discuss the concept of threads further in the lab sessions. The thread should pick a message from a random list of messages, and add it to the multiple-row textbox. The idea is that the thread simulates 'real' chat messages.
\end{enumerate}
By solving (a) to (c), we build a 'dummy prototype' for the client side of a chat system. In assignment 2, we will elaborate on the application to provide it with real chat functionality. However, in this assignment, we concentrate on building a GUI and some test functionality to simulate chat messages. In the lab sessions, we will discuss how to structure the code to make it as easy as possible to make the transfer from dummy messages to 'real' chat functionality.

Work in pairs. You are completely free to discuss with other groups, as long as you are able to understand and motivate your solution in the examination seminar.
\subsection{Chat system}
In this exercise, you have been given a partially completed solution for a full chat system. Both the client project and the server project are incomplete and contain errors. jointly build a chat server in the lab room. Your mission is to complete this solution and make it a working chat system. If you wish to use your chat client GUI created in the last exercise you are most welcome to do so.












\pagebreak
\section{Iterator}
This exercise consist of the following three steps.
\begin{enumerate}
  \item Implement the phone book examples from the notes.
  \item Refactor the find method to throw an exception instead of returning -1
  \item Develop a class diagram for the iterator.
  \item Implement the iterator pattern for the phone book, populate the phone book and iterate over it, printing its contents.
\end{enumerate}



\end{document}
