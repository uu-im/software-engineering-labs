\documentclass{article}
\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{hyperref}




% terminal code styling
% invoke using \begin{lstlisting}[style=terminal]
\lstdefinestyle{terminal}{
  basicstyle=\color{white}\ttfamily,
  keywordstyle=\color{white},
  numberstyle=\color{white},
  commentstyle=\color{white},
  stringstyle=\color{white},
  backgroundcolor=\color[rgb]{.1,.1,.1},
}

% csharp code styling
% (as default to save typing)
\lstset{
  language=[Sharp]C,
  basicstyle=\color[rgb]{0.3,0.3,0.3}\ttfamily,
  keywordstyle=\color[rgb]{0,0.5,0.5},
  numberstyle=\color[rgb]{0.7,0.7,0.7},
  commentstyle=\color[rgb]{0.1,0.5,0.1},
  stringstyle=\color[rgb]{0.6,0.1,0.5},
  backgroundcolor=\color[rgb]{0.95,0.95,0.95},
  showstringspaces=false
}

% steps
\newcounter{stepcounter}
\setcounter{stepcounter}{0}
\newenvironment{steps}{ 
  \begin{enumerate}[label=\color{red}Step \theenumi)]
    \setcounter{enumi}{\value{stepcounter}}
}{
  \setcounter{stepcounter}{\value{enumi}}
  \end{enumerate}
}

% hrefs
\hypersetup{
  colorlinks=true,
  urlcolor=cyan
}


\begin{document}

  \title{ Software Engineering | Lab 1 }
  \author{ Uppsala University }
  \date{ Spring 2014 }
  \maketitle

  \lstset{language=[Sharp]C}







\section*{ Introduction }
In this first block we’ll refresh our object oriented skills and dive into concepts such as constructors, public and private membership, interfaces and inheritance as well as a couple of more technical features such as threads and GUI’s.










\pagebreak
\section{ A Simple Ticket Machine }
The purpose of this first exercise is simply to get up to speed. Familiarize ourselves with the C\# language, Visual studio environment and refresh our knowledge in object oriented programming.

In this exercise we’re building a very simple ticket machine. You can think of the ticket machine as an automated ticket machine at the cinemas. You insert money, press ok, and get a ticket.


\subsection{An interface for the ticket machine}
Naturally we'll build thins ticket machine as a class. The class will be called \texttt{TicketMachine} and it will contain a number of public methods. Let's describe the class using a \texttt{C\# interface}.

\begin{lstlisting}
interface ITicketMachine {
  string InsertMoney(int amount);
  string ShowPrice();
  string ShowBalance();
  string RefundMoney();
  string PrintTicket();
}
\end{lstlisting}
\begin{steps}
\item Open up \texttt{Visual Studio} and create a new \texttt{C\#} solution. Make sure you choose \texttt{C\#} as the language, and not \texttt{Visual Basic} or any other language.
\item Add a new interface file to your project. Call it \texttt{ITicketMachine} and save it as \texttt{ITicketMachine.cs}.
\item Make sure your interface looks like the code example above.
\end{steps}





\subsection{Implementing the interface}
Let’s create the actual class. The ticket machine that will implement the interace.
\begin{steps}
\item Create a new class called \texttt{TicketMachine.cs} and tell it to implement the interface we just created. Like so:
\end{steps}
\begin{lstlisting}
class TicketMachine : ITicketMachine
{
}
\end{lstlisting}
\begin{steps}
\item Build the project (by pressing \texttt{F5}) and contemplate why it won't build.
\end{steps}
To make sure the application will build. Let's actually implement the members of the interface in the concrete ticket machine class.
\begin{steps}
\item Open the concrete ticket machine class and right-click the name of the interface in the class definition. Then select \texttt{Implement Interface > Implement Interface}. Or simply implement all of the members of the interface manually.
\end{steps}
\begin{lstlisting}
class TestMachine : ITicketMachine
{
  public string InsertMoney(int amount){
    throw new NotImplementedException();
  }
  public string ShowBalance(){
    throw new NotImplementedException();
  }
  public string ShowPrice(){
    throw new NotImplementedException();
  }
  public string RefundMoney(){
    throw new NotImplementedException();
  }
  public string PrintTicket(){
    throw new NotImplementedException();
  }
}
\end{lstlisting}
Superb! Now we, at least, have an application that builds.


\subsection{Command line interface}
So, now we have the ``shell'' for a class that will act as the ticket machine. But we need a way to interact with the ticket machine. I.e. we need a class that will use the ticket machine class.

For the sake of simplicity you've been provided with a command line interface (CLI) class that you can \href{https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/b1-oop/code/TicketMachine/TicketMachine/TicketMachineInteractor.cs}{download here}.

In your main \texttt{Program.cs} class you can then interact with the \texttt{TicketMachineInteractor} like so:

\begin{lstlisting}
class Program{
  private static ITicketMachine TM;
  
  public static void Main(){
    // Instantiate a ticket machine
    ITicketMachine tm = new TicketMachine();

    // Instantiate an interactor, and pass in the ticket machine
    TicketMachineInteractor interactor = new TicketMachineInteractor(tm);

    // Start the interactor
    interactor.Start();
  }
}
\end{lstlisting}

Ok, let’s now create a CLI so that we can interact with our TicketMachine class. You should already have a file called Program.cs. Copy and paste the following code into this file. Have a look at the contents of this code and discuss it with a lab partner.

\begin{steps}
\item Try running your application!
\end{steps}
The output should be similar to this:

\begin{lstlisting}[style=terminal]
 (q) Quit
 (i) Insert money
 (b) Show balance
 (p) Show price
 (r) Refund money
 (t) Print ticket
 ==============================================
 Choose action (h for help)
 >
\end{lstlisting}
If you, when running your application, do make one of the choices above -- of course a \texttt{NotImplementedException} will be thrown because that's all our concerete Ticket Machine does for now.




\subsection{Ticket Machine ticket costs}
Before we get into implementing the body of each method in the concrete ticket machine class -- let's declare a constructor. The constructor will take an integer as an argument. The integer represents the price of a single ticket. Consequently, our constructor needs to save the value passed in, as an instance variable so that we can use it later on. We need it to  Let's do it:
\begin{steps}
\item Implement a constructor in the ticket machine class, that takes an integer as an argument, and saves that value to an instance variable.
\end{steps}
\begin{lstlisting}
class TicketMachine : ITicketMachine{
  private int price;

  public TicketMachine (int ticketCost){
    this.price = ticketCost;
  }
}
\end{lstlisting}



\subsection{Full implementation}
Now it's time to actually implement the members of the concrete ticket machine class. Below you'll find a runtime example of what a session with the ticket machine could look like.
\begin{lstlisting}[style=terminal]
 Choose action (h for help)
 >   i
 >>> Enter the amount you wish to insert (SEK):
 >   50
 >>> Inserted 50 kr
 ==============================================
 Choose action (h for help)
 >   t
 >>> Insufficient funds.. Missing 150 kr
 ==============================================
 Choose action (h for help)
 >   p
 >>> The price of one ticket is 200 kr
 ==============================================
 Choose action (h for help)
 >   i
 >>> Enter the amount you wish to insert (SEK):
 >   175
 >>> Inserted 175 kr
 ==============================================
 Choose action (h for help)
 >   t
 >>> Printing ticket....
 ==============================================
 Choose action (h for help)
 >   b
 >>> Your balance is currently: 25 kr
 ==============================================
 Choose action (h for help)
 >   i
 >>> Enter the amount you wish to insert (SEK):
 >   75
 >>> Inserted 75 kr
 ==============================================
 Choose action (h for help)
 >   r
 >>> Refunding 100 kr
 ==============================================
 Choose action (h for help)
 >
\end{lstlisting}
If you find the runtime example above too confusing -- there's some comments below explaining what each method should do. Please note: all the methods return strings that will be printed by the interactor.

\begin{lstlisting}
public string InsertMoney(int amount){
  // update the current balance as defined by amount
  // only if amount is greater than 0
  // return string that explains what happened
}
public string ShowBalance(){
  // return a string that describes the current balance
}
public string ShowPrice(){
  // return a string that describes the price of a ticket
}
public string PrintTicket(){
  // if balance is enough
  //    reduce balance accordingly, and
  //    return string describing ticket
  // if balance is not enough
  //    return error message and amount missing
}
public string RefundMoney(){
  // print the amount of money refunded
  // reset the current amount and print it
}
\end{lstlisting}
Consequently the last task of this exercise is to...
\begin{steps}
\item Implement the intended functionality of all the \texttt{ITicketMachine} members in the concrete \texttt{TicketMachine}.
\end{steps}














\pagebreak
\section{More Ticket Machines}
So your ticket machine is fully functional. Yay, celebrate! However, let’s now look at how much abstraction we’ve achieved with our current implementation of the ticket machine. Does our ticket machine allow different prices, or other payment schemes? Let’s try it out.
\subsection{Altering the price}
Try instantiating the ticket machine with a different price. Such as:
\begin{lstlisting}
"Program.cs"

...
public static void Main ()
{ 
  TM = new TicketMachine (1020);
  // or maybe even
  TM = new TicketMachine(40500);
...
\end{lstlisting}
We could of course even alter the price at \textbf{runtime}. Try this out:
\begin{lstlisting}
"Program.cs"

...
public static void Main ()
{ 
  Console.Write("How much is a ticket (SEK): ");
  int price = Console.ReadLine();
  TM = new TicketMachine (price);
...
\end{lstlisting}
\subsection{The power of programming towards interfaces}
Now let’s look at the mighty power of programming towards interfaces. We will be creating a donation machine with slightly different behavior. Create a new file called DonationMachine.cs and paste in the following class.
\begin{lstlisting}
"DonationMachine.cs"

public class DonationMachine : ITicketMachine
{
  int price, balance, total;

  public DonationMachine (int minimumDonation)
  {
    this.price = minimumDonation;
    this.balance = 0;
    this.total = 0;
  }
  
  public int GetTicketPrice(){
    return this.price;
  }
  
  public int GetBalance(){
    return this.balance;
  }
  
  public void InsertMoney(int amount){
    if (amount >= this.price) {
      this.balance += amount;
      Console.WriteLine ("* * * * * * * * * * * * * * * *");
      Console.WriteLine ("* THANK YOU FOR YOUR DONATION :)");
      Console.WriteLine ("* " + this.balance + " SEK");
      Console.WriteLine ("* * * * * * * * * * * * * * * *");
    }  else {
      Console.WriteLine("# The minimum donation is: " + this.price);
    }
  }
  
  public void PrintTicket(){
    Console.WriteLine ("* * * * * * * * * * * * * *");
    Console.WriteLine ("* THIS MACHINE HAS COLLECTED");
    Console.WriteLine ("* Total: " + this.total + " SEK");
    Console.WriteLine ("* Thank you everyone :)");
    Console.WriteLine ("* * * * * * * * * * * * * *");
  }
  
  public void RefundMoney(){
    Console.WriteLine ("# Sorry, no refunds");
  }
}
\end{lstlisting}
Make sure you now instantiate the DonationMachine instead of the TicketMachine from the main class. As below:
\begin{lstlisting}
"Program.cs"

...
public static void Main ()
{ 
  TM = new DonationMachine (1020);
...
\end{lstlisting}
Run the application! Think about how little modification we had to do to the command line interface (Program.cs). The only thing we changed was the hard-coded instantiation of the class. Furthermore, this problem of instantiation is something that we will discuss further when looking at design patterns.
\subsection{A parking machine - your turn!}
Now let’s try to build a parking meter machine without changing anything, except which class we’re instantiating in Program.cs like so:
\begin{lstlisting}
"Program.cs"

...
public static void Main ()
{ 
  TM = new ParkingMachine (20);
...
\end{lstlisting}
And also creating the class, as follows:
\begin{lstlisting}
"ParkingMachine.cs"

public class ParkingMachine : ITicketMachine
{
  ... write your definition here ...
}
\end{lstlisting}
While the parking meter machines have different behaviors in different places this particular machine works just like the TicketMachine in the first assignment. Except for the following few things.
\begin{itemize}
  \item The price is the value of 10 minutes of parking
  \item So when the user asks for a ticket the ticket must show how many minutes of parking the user receives
  \item Parking time can only be in full multiplications of 10 minutes, the rest the user will receive as change.
  \item So, if the price of a ticket is 5 SEK, and the user inserts 13 SEK, the parking time would be 20 minutes, and the change 3 SEK.
\end{itemize}
\subsection{When you are done...}
Consider again the power of interfaces. While the above examples might be slightly contrived, take a minute to consider the implications of adding a class such as the one below.
\begin{lstlisting}
public class ExternalTicketMachine : ITicketMachine
{ 
  private int price, balance;

  public ExternalTicketMachine ()
  {
    this.price = // make a web request to get the price of a ticket
    this.balance = 0;
  }

  public int GetTicketPrice(){
    // make a web request to get the price of a ticket
  }

  public int GetBalance(){
    // return current balance
  }

  public void InsertMoney(int amount){
    // increase current balance
  }

  public void PrintTicket(){
    // make a web request to an external service
    // sending some user details and the current balance
    // returning the ticket recieved by the web request call
  }

  public void RefundMoney(){
    // refund money
  }
}
\end{lstlisting}
When we are programming to interfaces we are more prepared for change.














\pagebreak
\section{Basic GUI coding and Event Handling}
In this assignment, you should build a basic desktop application using Microsoft Visual Studio. The assignment should be solved using the programming language C\#.NET. The course literature McConnell (2009) primarily shows code examples in VB.NET and C++. It is up to you to and good C\# tutorials on Internet.
\begin{enumerate}
  \item The application should be a windows application consisting of one form. On that form, place one multiple-row textbox component, one listbox with dummy content (e.g. \texttt{"line1"}, \texttt{"line2"} et cetera) and one single-row textbox component. When something is written in the single-line textbox and \texttt{ENTER} is pressed, you should take the selected value from the listbox (e.g. \texttt{"line 1"}, 14 merge it with \texttt{" : "} and the content of the single-row textbox. Then you should add the result string to the multiple-row textbox.
  \item Add a button on the form with the text \texttt{"Store message"}. When the button is clicked, the content of both text boxes should be cleared.
  \item Add another button on the form with the text \texttt{"Start simulation"}. When the button is pressed, you should start a new thread. We will discuss the concept of threads further in the lab sessions. The thread should pick a message from a random list of messages, and add it to the multiple-row textbox. The idea is that the thread simulates 'real' chat messages.
\end{enumerate}
By solving (a) to (c), we build a 'dummy prototype' for the client side of a chat system. In assignment 2, we will elaborate on the application to provide it with real chat functionality. However, in this assignment, we concentrate on building a GUI and some test functionality to simulate chat messages. In the lab sessions, we will discuss how to structure the code to make it as easy as possible to make the transfer from dummy messages to 'real' chat functionality.

Work in pairs. You are completely free to discuss with other groups, as long as you are able to understand and motivate your solution in the examination seminar.
\subsection{Chat system}
In this exercise, you have been given a partially completed solution for a full chat system. Both the client project and the server project are incomplete and contain errors. jointly build a chat server in the lab room. Your mission is to complete this solution and make it a working chat system. If you wish to use your chat client GUI created in the last exercise you are most welcome to do so.












\pagebreak
\section{Iterator}
This exercise consist of the following three steps.
\begin{enumerate}
  \item Implement the phone book examples from the notes.
  \item Refactor the find method to throw an exception instead of returning -1
  \item Develop a class diagram for the iterator.
  \item Implement the iterator pattern for the phone book, populate the phone book and iterate over it, printing its contents.
\end{enumerate}



\end{document}
