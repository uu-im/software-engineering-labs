include partials/layout
+layout("Block 2")
  header
    h1 Software Engineering &mdash; Lab 2
    p Spring 2014



  .preamble
    p It's time to get in to design patterns. During this lab we'll practice UML, explore design patterns, and eventually refactor the chat systems we built during the first block. Using our design pattern skills.

    p Try to work in pairs and take turns writing code!


  h2 Study material
  p Please do familiarize yourself with (as much as you find necessary of) the following study material before attempting to approach the corresponding lab exercises. Naturally, all of the study material is not mandatory. But in relation to the labs, you will benefit greatly from exploring it.

  p Coming soon...
  // h3 Topic
  // ul
  //   li
  //     a(href="#") Link
  //     |  (~5 min video)







  h2 Deliverables
  p This is a summary of the deliverables for this block.

  p Coming soon...
  // h3 Exercise 1 &mdash; 
  //   a(href="#exercise-1") Introduction to testing
  // p One Visual Studio solution.
  // ol
  //   li
  //     code MathUtils
  //     |  (<em>Visual Studio</em> solution)








  h2#exercise-1 Exercise 1 &mdash; Modelling Use Cases with UML (optional)
  p Consider the requirements for the following library system:

  ul
    li The library lends books and magazines to borrowers who registered in the system (as are the books and magazines).
    li The library handles the purchase of new titles. Old books and magazines are removed when they are out of date or in poor condition.
    li The librarian is an employee of the library who interacts with the customs (borrowers) and whose work is supported by the system.
    li A borrower can reserve a book or magazine that is not currently available, so that when it is returned they're notified.
    li The reservation is canceled when the borrower checks and the book or magazine, or through an explicit cancelling procedure.
    li The librarian can create, update, and delete information about titles, borrowers, loans, and reservation in the system.
  p
    b Task 
    | &mdash; Identify the actors and create a use case diagram of the library system.







  h2#exercise-2 Exercise 2 &mdash; UML Class Diagrams (optional)
  p A customer wants to make an order from a retail catalog. The customer can make the payment in one of these three kinds: cash, cheque, or credit card. The order contains order details, each with its associated item. Each order carries the date in which it has been posted and its status (pending, delivered, etc).
  p
    b Task 
    | &mdash; Create a class diagram from the above description, begin with a noun and verb analysis.







  h2#exercise-3 Exercise 3 &mdash; Reverse engineering with UML (optional)
  p In this exercise, you are expected to ``reverse engineer" the chat system you built in block one. If you managed to get the chat system fully functional during the first block then use that version. If not, use the chat-mock that you built.

  p
    b Task 
    | &mdash; Model <em>class diagrams</em> that represent the way your solution currently works.








  h2#exercise-4 Exercise 4 &mdash; Observer Pattern
  p Implement the <em>Observer</em> pattern that we discussed in the lectures using the  Weather Station Project as inspiration. You will have to change the code from Java to C#.  Add the Heat Index display element as described on page 61.







  h2#exercise-5 Exercise 5 &mdash; Command Pattern
  p The fragment below is the core of a calculator implemented using the <em>Command Pattern</em>. Develop the rest of the code and demonstrate it running on a variety of sample input.

  pre.language-csharp
    code
      | class CalculatorCommand : ICommand
      | {
      |   public char Operator{ get; private set; }
      |   public int Operand{ get; private set; }
      | 
      |   private Calculator _calculator;
      | 
      |   // Constructor
      |   public CalculatorCommand(Calculator calculator,
      |     char @operator, int operand)
      |   {
      |     _calculator = calculator;
      |     Operator = @operator;
      |     Operand = operand;
      |   }
      | 
      |   // Execute new command
      |   public void Execute()
      |   {
      |     _calculator.Operation(Operator, Operand);
      |   }
      | 
      |   // Unexecute last command
      |   public void UnExecute()
      |   {
      |     _calculator.Operation(undo(Operator), Operand);
      |   }
      | 
      |   // Returns opposite operator for given operator
      |   private char undo(char @operator)
      |   {
      |     switch (@operator)
      |     {
      |       case '+': return '-';
      |       case '-': return '+';
      |       case '*': return '/';
      |       case '/': return '*';
      |       default: throw new
      |        ArgumentException("@operator");
      |     }
      |   }
      | }












  h2#exercise-6 Exercise 6 &mdash; Visitor Pattern
  p Develop a <em>Visitor</em> pattern to calculate the salary of employees, that can be composed of secretaries and managers, like we saw in the second week of the course.













  h2#exercise-7 Exercise 7 &mdash; Choose a pattern
  p Implement one other of the following patterns according to the course book:

  ul
    li Decorator pattern
    li Factory pattern
    li Singleton pattern
    li Adapter or Facade pattern
    li Template method pattern
    li Composite pattern
    li State pattern
    li Proxy pattern







  h2#exercise-8 Exercise 8 &mdash; Applying design patterns to existing code
  p When building the chat system in block 1, little attention was paid to design principles and patterns of software design. In this assignment you are expected to systematically analyze your chat system and make changes to the design.

  p 
    b Task
    |  &mdash; Take at least <em>three patterns into consideration</em>, writing down your reflections. Implement all of which of the three you find appropriate, and keep a written log of the changes you make. <em>At least one</em> pattern has to be implemented.

  ul
    li
      b  Larman’s creator pattern
      |  &mdash; Are objects created in the right place?

    li
      b  Larman’s expert pattern
      |  &mdash; Is the responsibility to do things assigned to the correct classes?

    li
      b  Dependency Inversion principle
      |  &mdash; Are there dependencies between concrete system parts that may cause problems to maintain and extend the code? Could these dependencies be removed, e.g. through strategically design interfaces?

    li
      b  Observer pattern
      |  &mdash; How is different parts of the system being notified of change in state? Could an event-driven solution be beneficial?

    li
      b  Decorator pattern
      |  &mdash; Does any class need a change in its responsibility during runtime?

    li
      b  Factory pattern
      |  &mdash; Is the system suffering from high coupling and dependencies or repetitive complex instantiation of objects?

    li
      b  Singleton pattern
      |  &mdash; Do your system need to keep track of objects from a specific type? Should the solution be simplified with just having a single object of that type?

    li
      b  Command pattern
      |  &mdash; Could some part of the system benefit from encapsulate method invocation?

    li
      b  Model View Controller pattern
      |  &mdash; Is managing the entire system overwhelming, could MVC keep it manageable.
  

  p Further, you should take this following principles into consideration:

  ul
    li
      b  The single responsibility principle
      |  &mdash; Does every single class in the solution have a single responsibility?

    li
      b  Open-closed principle
      |  &mdash; Is the code possible to change without making changes to the existing code?

    li
      b  Interface segregation principle
      |  &mdash; Are there interfaces in the code that could be logically separated into several smaller interfaces?

  p Be sure you keep a copy of the original chat system. So that after solving this assignment you have two different designs of the chat system. During the re-design, keep a written log of the changes you make and the reason for them. An example of an entry in this log could be:

  blockquote
    em May 1, 2013: New class named X. 
    | The class X was introduced since the creation of objects of type Y didn't fit into the responsibility of any of the existing classes. Class X creates objects of the types Y in accordance with Larman's creator pattern.



