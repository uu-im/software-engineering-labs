include ../../_mixins


+layout('Lab Guidelines')
  header
    h1 Lab Guidelines

  p While we encourage you to explore the vast array of principles, guidelines and refactoring techniques that exist out there, you should at the very least always deliberately attempt to consider the following:

  ul
    li
      a(href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)") Low coupling, high cohesion.
    li
      a(href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)") The SOLID design principles.
    li
      a(href="http://shop.oreilly.com/product/9780596007126.do") The Design Patterns in Head First: Design Patterns.

  p Further, you should of course <u>always</u> exercise basic "housekeeping" of your code:
  ul
    li Indent properly.
    li Be consistent in the "style" you write code (e.g. whitespace, cuddled curly-brackets, etc.).
    li Use sensible variable names.
    li Never leave old commented code.
    li Never leave "dead" code.
    li Never hand in code with failing tests.
    li Never hand in broken code.





//  h2 Patterns considered in this course
//
//  dl
//    dt Adapter or Facade
//    dd Do you need to make an incompatible object compatible without changing its internals?
//
//    dt Command
//    dd Could some part of the system benefit from encapsulating method invocation?
//
//    dt Composite
//    dd Can the parts be treated as the whole?
//
//    dt Decorator
//    dd Does any class need a change in its responsibility during runtime?
//
//    dt Factory
//    dd Is the system suffering from high coupling and dependencies or repetitive complex instantiation of objects?
//
//    dt Model View Controller
//    dd Is managing the entire system overwhelming, could MVC keep it manageable?
//
//    dt Observer
//    dd How is different parts of the system being notified of change in state? Could an event-driven solution be beneficial?
//
//    dt Proxy
//    dd Are you making complex calls to objects that could be bundled and proxied?
//
//    dt Singleton
//    dd Do your system need to keep track of objects from a specific type? Should the solution be simplified with just having a single object of that type?
//      | (Note that many have argued that 
//      a(href="https://www.youtube.com/watch?v=-FRm3VPhseI") this pattern is an anti-pattern
//      |)
//
//    dt State
//    dd Does behavior vary greatly depending on an object's state?
//
//    dt Strategy
//    dd Are there families of algorithms where the members are virtually interchangable?
//
//    dt Template method
//    dd Does an algorithm consist of recurring steps who's implementations can be deferred to subclasses.






