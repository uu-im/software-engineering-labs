include partials/layout
+layout("Block 2")
  header
    h1 Software Engineering &mdash; Lab 2
    p Spring 2014

  .preamble
    p In this block we'll focus on <em>testing</em> and <em>refactoring</em>. While there are many ways to test code we will focus on <a href="http://en.wikipedia.org/wiki/Unit_testing">unit testing</a>. In essance, unit testing means testing individual functions in isolation. Asserting that some given input yield expected output.

    p In regards to testing we'll look at a couple of different aspects of testing. Such as:
    ul
      li Testing as a means of making sure our code actually does what it's supposed to.
      li Testing as a means of discovering, isolating and preventing unnoticed reoccurance of bugs.
      li The concept of <em>test coverage</em>, often times called <a href="http://en.wikipedia.org/wiki/Code_coverage">code coverage</a>, as a means of measuring how much of a code base that is covered by tests. An issue <a href="http://martinfowler.com/bliki/TestCoverage.html">open for debate</a>.
      li Three different "schools" of testing:
        ul
          li
            a(href="http://stackoverflow.com/questions/7199313/what-are-the-pitfalls-of-test-after-development") Test-after development 
            |, 
          li  
            a(href="http://www.extremeprogramming.org/rules/testfirst.html") Test-first development 
            | (or more specifically 
            a(href="http://en.wikipedia.org/wiki/Test-driven_development") Test-driven development
            | ), and finally
          li 
            a(href="http://stackoverflow.com/questions/7690238/test-driven-development-initial-implementation") Exceptionally strict test-driven development
            |  &mdash; often dubbed "sliming".

    p Apart from testing, we'll also look at the art of refactoring existing code. Using the classic example <a href="http://www.cs.unc.edu/~stotts/723/refactor/chap1.html">movie rental case</a> by <a href="http://en.wikipedia.org/wiki/Martin_Fowler">Martin Fowler</a>.

    p
      em <strong>Important:</strong> The optional exercise in this block is really optional. There is no requirement to complete at least one optional exercise in this block.



  h2 Study material
  p Please do familiarize yourself with (as much as you find necessary of) the following study material before attempting to approach the corresponding lab exercises. Naturally, all of the study material is not mandatory. But in relation to the labs, you will benefit greatly from exploring it.
  h3 Testing
  ul
    li
      a(href="https://www.youtube.com/watch?v=QCif_-r8eK4") What is TDD?
      |  (~5 min video)
    li
      a(href="http://www.youtube.com/watch?v=5gMBGVNR8wE") TDD in Visual Studio using C#
      |  (~17 min video)
    li
      a(href="https://www.youtube.com/watch?v=xX9hfPkA800") A TDD pair-programming session
      |  (~2 h video)
    li
      a(href="http://feelings-erased.blogspot.se/2013/03/the-two-main-techniques-in-test-driven.html") "Sliming" / "Fake it 'til you make it"
      |  (blog post) 
    li
      a(href="http://blog.james-carr.org/2006/11/03/tdd-anti-patterns/") TDD anti-patterns
      |  (blog post) (i.e. things you should not do)
  h3 Refactoring
  ul
    li
      a(href="http://en.wikipedia.org/wiki/Code_refactoring") What is refactoring?
      |  (Wikipedia)
    li
      a(href="http://www.cs.unc.edu/~stotts/723/refactor/chap1.html") Refactoring, a first example
      |  (A great example of refactoring by Martin Fowler)
    li Examples of Martin Fowler's refactoring technique (from his book 
      a(href="http://martinfowler.com/books/refactoring.html") Refactoring &mdash; Improving the design of existing code
      | ). Explained by some dude on youtube.
      ol
        li
          a(href="https://www.youtube.com/playlist?list=PL3GKSsHsE_qKWl5-XWAX6jACpfId_9-8Y") Composing methods
          |  (video playlist)
        li
          a(href="https://www.youtube.com/playlist?list=PL3GKSsHsE_qJX-E7GuBkKJ8-BoyiThrk7") Moving Features Between Objects
          |  (video playlist)
        li
          a(href="https://www.youtube.com/playlist?list=PL3GKSsHsE_qJ54Q3oJ3GNVj8WkFZd6y2y") Organizing data
          |  (video playlist)
        li
          a(href="https://www.youtube.com/playlist?list=PL3GKSsHsE_qIv4gbun2h268rBc2-RnyNH") Simplifying Conditional Expressions
          |  (video playlist)
        li
          a(href="https://www.youtube.com/playlist?list=PL3GKSsHsE_qJwgtU88VFGq6cmewrdorxh") Making Method Calls Simpler
          |  (video playlist)
        li
          a(href="https://www.youtube.com/playlist?list=PL3GKSsHsE_qLVoAoWooC0yk59RLwV4rfW") Dealing With Generalization
          |  (video playlist)



  h2 Deliverables
  p This is a summary of the deliverables for this block.

  h3 Exercise 1 &mdash; 
    a(href="#exercise-1") Introduction to testing
  p One Visual Studio solution.
  ol
    li
      code MathUtils
      |  (<em>Visual Studio</em> solution)

  h3 Exercise 2 &mdash; 
    a(href="#exercise-2") Debugging via Tests
  p One Visual Studio solution and one text file.
  ol
    li Matrix (<em>Visual Studio</em> solution)
    li Contemplation (Text file in <code>.txt</code>-format)

  h3 Exercise 3 &mdash; 
    a(href="#exercise-3") Refactoring
  p One Visual Studio solution and one text file.
  ol
    li MovieRental (<em>Visual Studio</em> solution)
    li Contemplation (Text-file in <code>.txt</code>-format)

  h3 Exercise 4 &mdash;
    a(href="#exercise-4") Test Coverage
  p One Visual Studio solution and one diagram.
  ol
    li PhoneBook (<em>Visual Studio</em> solution)
    li Contemplation (Text-file in <code>.txt</code>-format)

  h3 Exercise 5 &mdash; 
    a(href="#exercise-5") Testing to drive design
  p Three Visual Studio projects (preferably in the same solution) and one text file.
  ol
    li Testing (Visual Studio solution containing the following projects..)
    ol
      li TAD (<em>Visual Studio</em> project) 
      li TDD (<em>Visual Studio</em> project)
      li Sliming (visual Studio project)
    li Contemplation (text document in <code>.txt</code> format)

  h3 Exercise 6 &mdash; 
    a(href="#exercise-6") TDD Practice
    |  (optional)
  p One Visual Studio solution and one text file.
  ol
    li BowlingGameKata (<em>Visual Studio</em> solution)
    li Contemplation (Text-file in <code>.txt</code>-format)











  h2#exercise-1 Exercise 1 &mdash; Introduction to testing
  p In this exercise we're going to familiarize ourselves with the concept of unit testing.
  ol
    li Create a new Visual Studio Solution.
    li Add a new 
      code Class Library
      |  project, and name it 
      code MathLibrary
      |.
    li Add a new 
      code Unit Test Project
      |  and name it 
      code MathLibraryTests
    li Create a new class in your <code>MathLibrary</code> project. Name it <code>MathLib.cs</code>.
    li Copy the contents of the  
      a(href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/MathLibrary/MathLibrary/MathLib.cs") <code>MathLib</code> example class
      |  and paste it into your class file.
    li Create a new class in your <code>MathLibraryTests</code> project. Name it <code>MathLibTests</code>.
    li Copy the contents of the 
      a(href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/MathLibrary/TestProject/MathLibraryTests.cs") <code>MathLibTests</code> example class
      |  and paste it into your class file.
    li Add a reference (via <code>Solution Explorer</code>) to the <code>MathLibrary</code> project in the <code>MathLibraryTests</code> project. We do this because the test project is going to test classes in the <code>MathLibrary</code> project.
  p So, if you've set up your solution according to the above, then we are ready to rock. The <code>MathLib</code> project contain a bunch of public static methods that does some math related stuff.
  p If you take a closer look at the <code>MathLib</code> class you'll notice that not all methods are fully implemented. If you take a closer look at the <code>MathLibTests</code> class you'll notice that not all tests are fully implemented. However you've been given the outline. 
  p In this exercise you should not add or remove any public methods or tests. Your job is to:
  ol
    li Complete the implementation of each method in the <code>MathLib</code> class.
    li Complete the implementation of each test method in the <code>MathLibTests</code> class.
  p Remember to continuously run your tests. And remember that tests without implementation report "false positives". Meaning that tests without implementation are listed as "passing" tests. 







  h2#exercise-2 Exercise 2 &mdash; Debugging via tests
  p In this exercise we're going to explore the idea of using tests as a means of locating bugs.

  p Start off by 
    a(href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/MatrixUtils/MatrixUtils/Matrix.cs") downloading this <code>Matrix</code> class
    |. Supposedly, it was written by a really lousy programmer. And consequently it contains a bunch of bugs. More specifically a bunch of logical errors.

  p Create a new solution. Add in the <code>Matrix</code> class. And create a test project.

  p Your job is to eliminate all bugs in the <code>Matrix</code> class. You must do this by introducing test cases that will help you determine where the errors actually reside.

  p
    em A matrix is a two-dimensional array of elements (in this case numbers). If you are not familiar with matrices, consult (e.g.) Wikipedia to learn how (e.g.) matrix multiplication is performed, and how to calculate the inverse of a 2x2 matrix. Some knowledge about matrix operations is vital, in being able to write good test cases for the class.






  h2#exercise-3 Exercise 3 &mdash; Refactoring
  p Now we're going to focus on refactoring. The process of rewriting existing code without changing it's functionality. Increasing readability and decreasing complexity.
  p The lousy programmer has been at it again. He/she has built a system for a movie rental shop handling customer orders. However, since the lousy programmer was focused on meeting the deadline the code is way more procedural than object oriented. Truth be told, the code you'll be given in this exercise is actually a classic example by author <a href="http://en.wikipedia.org/wiki/Martin_Fowler">Martin Fowler</a>.
  p First off, create a new <code>Console Application</code> in Visual Studio. Then download and copy in the contents of the following classes into your project.
  ul
    li
      a(href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/MovieRentalRefactoring/MovieRentalBefore/Customer.cs") Customer.cs
    li
      a(href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/MovieRentalRefactoring/MovieRentalBefore/DVD.cs") DVD.cs
    li
      a(href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/MovieRentalRefactoring/MovieRentalBefore/DomainObject.cs") DomainObject.cs
    li
      a(href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/MovieRentalRefactoring/MovieRentalBefore/Movie.cs") Movie.cs
    li
      a(href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/MovieRentalRefactoring/MovieRentalBefore/Rental.cs") Rental.cs
    li
      a(href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/MovieRentalRefactoring/MovieRentalBefore/Program.cs") Program.cs
      |  (main program file)


  p The <code>Customer</code> class has a <code>Statement()</code> method, that returns a string of information on a given customers current rentals. However, as a requirement to print the statement as a HTML formatted string just came in, the lousy programmer realized the code is not at all prepared for change. Because of the code's procedural nature, meeting the new requirements will be painful.

  p Your job is now to...
  ol
    li Refactor the whole project. Aiming for high readability, and low complexity. Avoiding duplication and increasing flexibility. Stop only when you find no more ways of refactoring to the better!
    li And then implement the <code>HtmlStatement</code> method.

  p To let you refactor with confidence, make sure you 
    a(href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/MovieRentalRefactoring/MovieRentalTests/CustomerIntegrationTests.cs") download this class containing an integration test
    |  for the <code>Statement</code> method. It also contains a test for the <code>HtmlStatement</code> method, however commented out. Make sure you uncomment that test when you begin working on the <code>HtmlStatement</code> method.

  p So, what to refactor? A good place to start is to have a look at the <code>Statement()</code> method itself. It is way too long! Apart from that, think about the following points:t

  ul
    li
      b Method extraction
      |  Can some behavior be extracted into a different method?
    li
      b Replacing case statements
      |  Can we use inheritance instead of case staements?
    li
      b Creation methods
      |  Can we use creation methods to make instantiation safer?
    li
      b Moving behavior
      |  Should a given behavior really be defined on another class? A rule-of-thumb is to consider the Law of Demeter, which say that a class should <em>only</em> talk to its closest neighbors. Meaning, it's OK to say: 
      code instanceOfSomeClass.Method()
      |  But it's not OK to say: 
      code instanceOfSomeClass.instanceOfSomeOtherClass.Method()

  p If you want a narrative that "talks you through" the refactoring process. It's highly recommended to check out 
    a(href="http://www.cs.unc.edu/~stotts/723/refactor/chap1.html") Martin Fowler's step-by-step approach
    |  to refactoring this particular system. The code is written in Java but you'll have no trouble translating it to C#.

  h3 Contemplation
  p Write a few sentances (max half-a-page) about your on the design improvements if your code. Which techniques did you use? Which ones not? Why? When are they suitable? etc.









  h2#exercise-4 Exercise 4 &mdash; Test coverage 
  p In this exercise we're going to attempt to achieve the mythical notion of <em>full test coverage</em>

  p Start off by 
    a(href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/code/block2/PhoneBook/PhoneBook/PhoneBook.cs") downloading the <code>PhoneBook</code> class
    | . It's very similar to the one you've been working with before.

  p Study the class and contemplate the details of what it does. What are the quirks? Think in terms of expected output in relation to varying input.

  p In a perfect world, we would write tests untill we achieve full test coverage. In a perfect world it will then be <strong>impossible</strong> to introduce errors to the class without any tests failing. This is, in theory, the highest possible level of test coverage.

  p In practice however it's all about compromise. It's not reasonable to assume that we can maintain a suite of tests that employ full test coverage.

  p Your job is consequently to create a test suite for the <code>PhoneBook</code> class. Aiming for as high test coverage as possible. You are of course allowed to refactor the <code>PhoneBook</code> class, to make it easier for you to handle.

  p When you believe you have achieved a high level of coverage. Grab a friend and let her or him try to make your tests report <em>false-positives</em>. A <em>false-positive</em> is when a test is passing, but the functionality it is supposed to test actually is broken. It's easy to get "snowblind" stairing at your own code so having someone else attempting to "break" it, is usually a good idea.

  h3 Contemplation
  p Does full test-coverage ensure perfect code? Is full test coverage possible? What is it good for? Not good for? How good is it? When is it relevant? When not? How much <em>can</em> we test? How much <em>should</em> we test? Is there a golden mean? Etc. Write a few sentances (max half-a-page) about your thoughts on the positives and negatives of test-coverage.







  h2#exercise-5 Exercise 5 &mdash; Testing to drive design
  p In this exercise we're going to build more or less the same application (a little thing called <code>FizzBuzz</code>) three times. But each time we'll use a different approach. Namely three different approaches to testing.

  p Below, three project specifications follow. Create all three as separate projects in the same <em>Visual Studio</em> solution. Name the projects as follows:
  ol
    li
      code FizzBuzzTAD
    li
      code FizzBuzzTDD
    li
      code FizzBuzzSliming
  p Also, you'll need to create a test project. For the sake of this project it's ok to keep all of your tests in one test project. However, you must put the tests in separate classes. Like so:
    ol
      li
        code FizzBuzzTADTests.cs
      li
        code FizzBuzzTDDTests.cs
      li
        code FizzBuzzSlimingTests.cs
  p ... or similarly.

  p The rules of the game of FizzBuzz reads as follows:
  ul
    li <code>Fizz</code> is returned, when given a number divisible by 3
    li <code>Buzz</code> is returned, when given a number divisible by 5
    li <code>FizzBuzz</code> is returned, when given a number divisible by 3 <strong>and</strong> 5
    li The input number itself is returned, when given an input number not divisible by 3 <strong>nor</strong> 5


  h3 5.1 Test-after development (TAD)
  p Create a new console project. Add a class called <code>FizzBuzz.cs</code>, and give it a public static method like so:
  pre
    code.language-csharp
      | class FizzBuzz{
      |     public static string FizzOrBuzz(int n)
      |     {
      |         // returns "Fizz" if divisible by 3
      |         // returns "Buzz" if divisible by 5
      |         // returns "FizzBuzz" if divisible by 3 and 5
      |     }
      | }
  p Your job is now to...
  ol
    li Implement the body of the <code>FizzOrBuzz(int n)</code> function, so that it behaves according to specification.
    p And when you're done. Then..
    li Create a test project and write suitable tests that will ensure reasonable test coverage of the method.

  p When you're done. Stop for a minute and consider how much code coverage you've achieved. Is it enough? Is it really hard to introduce errors without having tests that fail? Keep this question in mind as you move on to the next exercise.


  h3 5.2 Test-driven development (TDD)
  p We're now going to build the FizzBuzz application again, but this time through test-driven development (TDD). Create a new console project.
  p Remember, that we are now developing software according to the rules of TDD. This means that we at all times must follow the steps below.
  ol
    li Introduce a (or change an existing) test.
    li Watch the test fail (for the right reason).
    li Write the minimal code needed to make it pass.
  p An easy way to remember the above steps is to think of the idiom 
    a(href="http://en.wikipedia.org/wiki/Test-driven_development") red-green-refactor
    |. In essence the idea is we start by producing a state where we have a test that fails (red). Then we write enough code to make it pass (green). Only then, are we allowed to refactor code. When done we restart, by introducing another failing test.
  p This time we have some new requirements though. Another public static method must be added to the FizzBuzzer:
  pre
    code.language-csharp
      | public static string Count(int n){
      |   // FizzBuzz from 1 all the way up to n.
      |   // Example, if n = 5, then
      |   // return "1 2 Fizz 4 Buzz"
      | }


  h3 5.3 "Sliming"
  p Once again, we'll build the FizzBuzz application (with the new <code>Count(int n)</code>requirement). Once again, will we use use TDD. However this time we will "slime" every step of implementation. Start by creating a new console project.
  p Sliming (fake it 'til you make it) is a tactic used as a means to force yourself to ensure high test-coverage. Usually, when we are "writing the minimal code needed, we tend to write "sensible" code (the implementation we actually want). However "sliming" propose we indeed really should write the simplest possible code, no matter how dumb it is.
  p Say the goal is to produce a function such that <code>F(x)=x*x</code>. So we start by writing a test, that calls <code>F(2)</code>, and expects (asserts) a return value of <code>4</code>. If we are "sliming", then we write the simplest function we can possibly write to ensure the test is satisfied. So we write the following function:
  pre
    code.language-csharp
      | int F(int x){
      |   return 4;
      | }
  p Unintelligent code indeed. Say we continue by writing a new test, calling <code>F(10)</code>, that expects a return value of <code>100</code>. Since we are sliming, we will change our production code to the following:
  pre
    code.language-csharp
      | int F(int x){
      |   if(x == 2)
      |     return 4;
      |   else
      |     return 100;
      | }
  p Utterly stupid code, and as humans we know this is not even close to the final behaviour we want. However, by doing this process, we are forced to write more (or better) tests. We only stop sliming when it becomes harder than writing the implementation we actually want to write.
  p Your job is again to implement another version of the FizzBuzzer. If the above concepts however seem unfamiliar to you. Consult the reading material before you proceed.

  h3 Contemplation (TAD, TDD and Sliming)
  p What are the positives and negatives of TDD? TAD? Sliming? Write a few sentances (max half-a-page) about your thoughts on these concepts. When are they good to use? Less good? Was sliming helpful? Always? Never? Somwhat? Who are tests for? Is testing useful for only one or many things? What? Why? Does testing first improve design? If yes, in what way? If no, how come many claim that is the case?







  h2#exercise-6 Exercise 6 &mdash; TDD Practice &mdash; optional
  p Many developers use TDD to "drive" their design forward. Calling it Test Driven Design instead of simply Test Driven Development. Often times we loose focus and end up working on multiple things at once. This is unwanted for many reasons. For example it splits our attention, and cause our (version control) commits to be sprawled.

  p On the other hand, many developers find the cost of TDD to be too high in relation to it's payoff. Some disregard testing alltogether. Some disregard the idea of using tests as a way to drive design. In this exercise we'll approach a common programming exercise using the teachings of test driven design, and then reflect upon our findings.

  p A ``kata'' is used to practice one's programming skills. Much like musicians practice scales. This exercise asks you to perform, what has come to be known as, the Bowling Game Kata. The bowling game class exposes two public methods. Your job is to implement these bodies TDD-style.

  p Remember that this is an exercise in Test Driven Design. So you must follow the <em>red-green-refactor</em>-cycle at all times. And reflect upon the design decisions that you are making as you go along.

  pre
    code.language-csharp
      | void Roll(int pins)
      | // Where pins is the number of pins knocked
      | // down by the player in this roll
      | 
      | int Score()
      | // Returns the current score at the given time

  p The rules of bowling, and consequently the requirements of the game, are outlined below.
  ul
    li Each game consist of 10 frames (rounds)
    li Each frame consist of 2 rolls
    li Each roll can knock down 0-10 pins
    li The score for the frame is the total number of pins knocked down in that frame + plus bonuses for strikes and spares
    li A spare is when the player knocks down all 10 pins in two rolls
    li The score of a spare is the number of pins knocked down in the next roll
    li A strike is when the player knocks down all 10 pins in the first roll
    li The score of a strike is the number of pins knocked down in the next frame
    li A frame only consist of one roll if the player rolls a strike
    li In the tenth frame the player will have one extra roll <em>if</em> a strike or spare is rolled

  h3 Contemplation
  p Write a few sentances (max half-a-page) and reflect upon your new won experiences and opinions about using tests as a means to drive design. Does it help? Does it not? Does it enforce good design decisions. Does it enforce bad design decisions? Is it worth it?









