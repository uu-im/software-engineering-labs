include mixins/deliverables
include partials/layout

+layout("Block 1")
  header
    h1 Software Engineering &mdash; Lab 1


  .preamble
    p In this first block we'll refresh our object oriented skills by revisiting concepts such as constructors, public and private membership, interfaces and inheritance as well as threads and GUIs. Finally we'll take our first peek into the world of design patterns by implementing the <em>iterator pattern</em>.


  h2 Deliverables
  p Please follow the below folder/file structure for the handin of this block.

  +toc-exercises(1)
    +toc-exercise(1)
      +toc-assignment
        +vs-solution("TicketMachines") 
          //+vs-file [...]
          //+vs-file ITicketMachine.cs
          //+vs-file TicketMachine.cs
          //+vs-file DonationMachine.cs
          //+vs-file ParkingMachine.cs
      +toc-assignment
        +i-text
          code Contemplation.txt

    +toc-exercise(2)
      +toc-assignment
        +vs-solution("VisualTicketMachines")

    +toc-exercise(3)
      +toc-assignment
        +vs-solution("PhoneBook")
      +toc-assignment
        +file-img("IteratorDiagram.png")



  +assignment(0, "Interfaces")
    p The purpose of this exercise is to get up to speed, familiarize ourselves with C#, and explore the concept of programming towards interfaces.

    p Consider the following scenario. You are running a company that creates encryption algorithms. All algorithms are two-way. In other words, they can encrypt strings as well as decrypt strings.

    p Your company is currently aiming to implement all your algorithms in C# and bundle them all as a single DLL.

    p To facilitate standardization you've decided to create an interface for what all classes that contain encryption algorithms should look like. See below.

    pre
      code.language-csharp
        | interface IAlgorithm {
        |   string Encrypt(string input);
        |   string Decrypt(string input);
        |   string GetName();
        | }

    p Your job is now to create a class for each encryption algorithm. Each class must implement the interface properly, and must encrypt and decrypt according to specification.

    p I will show you how to implement the first algorithm, but you then have to implement the rest on your own.

    p The following is the specification for the first algorithm.

    table.table-border.cipher-specification
      tr
        th(colspan="2") Reversal algorithm
      tr
        td Name
        td The Reversal Algorithm
      tr
        td Description
        td Reverses the input string character by character.
      tr
        td Example input
        td
          code "Abc xyz"
      tr
        td Example output
        td
          code "zyx cbA"

    p Let's implement this algorithm. Create a new visual studio C# console project. Add a new interface file and copy in the <code>IAlgorithm</code> interface. Create a new class and copy in the following code.

    pre
      code.language-csharp
        | class ReversalAlgorithm : IAlgorithm
        | {
        |   string Encrypt(string input)
        |   {
        |     string reversed = "";
        |     for(int i=input.Length-1; i>=0; i--)
        |       reversed += input[i];
        |     return reversed;
        |   }
        |   
        |   string Decrypt(string input)
        |   {
        |     return Encrypt(input);
        |   }
        |   
        |   string GetName()
        |   {
        |     return "The Reversal Algorithm";
        |   }
        | }

    p Congratulations, you've now implemented the first one of the algorithms.

    p Notice how the class implements the interface in the top using the syntax <code>class ClassName : InterfaceName</code>.

    p Notice also how we reuse the Encrypt method in the Decrypt method since they essentially behave the same in this algorithm.

    p If you're wondering what the implications are of stating that the <code>ReversalAlgorithm</code> class implents the <code>IAlgorithm</code> interface, try temporarily removing one of the methods from the class and then compile the project by pressing F5. You get an error. Why?

    p Make sure your implementation is correct by pasting in the following program in to the main entry point of your application (most often the static <code>Main</code> method of the <code>Program</code> class in the <code>Program.cs</code> file).

    pre
      code.language-csharp
        | IAlgorithm algo = new ReversalAlgorithm();
        | string encrypted = algo.Encrypt("Hello world");
        | string decrypted = algo.Decrypt("sdrawkcaB");
        | Console.WriteLine("Hello world => " + encrypted);
        | Console.WriteLine("sssdrawkcaB => " + decrypted);
        | Console.ReadKey();

    pre.terminal
      | Hello world => dlrow olleH
      | sssdrawkcaB => Backwardsss

  p Notice that on the first line in the example program we're declaring the variable <code>algo</code> to be of type <code>IAlgorithm</code> not of type <code>ReversalAlgorithm</code>. This is the power of interfaces. Just like inheritance allows us to declare the base type and then instantiate any of the super types, interfaces allow us to declare the interface and then instantiate any one class that implements that interface.

  p This means that we can write programs towards the interfaces without knowing what kind of classes and implementations will show up in the future. As an example. Download the example class in the link below, add it to your project and then rewrite your main program as below.

  p
    a(href="../code/block1/Encryptor/Encryptor/EncryptoStream.cs")
      +i-text EncryptoStream.cs

  pre
    code.language-csharp
      | IAlgorithm algorithm = new ReversalAlgorithm();
      | 
      | EncryptoStream stream = new EncryptoStream(algorithm);
      | 
      | stream.Start();

  p You should now have a program that allows you to interactively encrypt and decrypt strings using your algorithm, and if you type in "Hello world" your terminal screen should look as follows.

  pre.terminal
    | The Reversal Algorithm
    | 
    | > Hello world
    | 
    | ENCRYPTED: dlrow olleH
    | 
    | DECRYPTED: Hello world


  p Let me tell you one final piece before I'll leave you to implementing the rest of the algorithms. Remember that interfaces only specifies the minimal requirements of a class. Interfaces do pose set any further restrictions on the class. This means that each class can do more than just these methods. This will be necessary since some of the algorithms are not as static as the reversal algorithm. The Caesar cipher, for example, requires that you give it a number that represents the number of shifts you want to shift a word with.

  p You're now ready to implement the rest of the algorithms. The specifications follow below.

  table.table-border.cipher-specification
    tr
      th(colspan="2") Caesar Cipher
    tr
      td Name
      td n-step Caesar Cipher
    tr
      td Description
      td Replaces each alphabetical character with an alphabetical character n steps further in the alphabet. The number of steps must be able to be assigned by the code that use the class, through for example the constructor.
    tr
      td Example input
      td
        code "Abcxyz"
    tr
      td Example output (n=1)
      td
        code "Bcdyza"


  table.table-border.cipher-specification
    tr
      th(colspan="2") 1337 Lang
    tr
      td Name
      td Language of the 1337's
    tr
      td Description
      td Replaces specific characters with numbers. Forces all strings to be lower case before encryption or decryption.
    tr
      td Charater replacement scheme
      td
        code a=&gt;4, b=&gt;6, e=&gt;3, g=&gt;9, i=&gt;!, l=&gt;1, o=&gt;0, t=&gt;7
    tr
      td Example input
      td
        code "Abcxyz"
    tr
      td Example output (n=1)
      td
        code "Bcdyza"


  table.table-border.cipher-specification
    tr
      th(colspan="2") Multicipher
    tr
      td Name
      td Generic multicipher
    tr
      td Description
      td Any number of <code>IAlgorithm</code> objects can be added to an instance of the <code>Multicipher</code> class at runtime. When encrypting, the algorithm runs each sub-algorithm on the input one after one. When decrypting it runs the algorithms one after one in the reverse order, but decrypting this time.
    tr
      td Charater replacement scheme
      td
        code a=&gt;4, b=&gt;6, e=&gt;3, g=&gt;9, i=&gt;!, l=&gt;1, o=&gt;0, t=&gt;7
    tr
      td Example input
      td
        code "Abcxyz"
    tr
      td Example output (assuming given both CaesarCipher(1) and 1337 Lang in that order)
      td
        code "6c0yz4"








  +assignment(1, "Interfaces")
    p The purpose of this first exercise is simply to get up to speed. Familiarize ourselves with the C# language, Visual studio environment and refresh our knowledge in object oriented programming.

    p We're building ticket machines to illustrate the power of programming towards interfaces rather than towards implementations. We'll start off with a very simple ticket machine, and later move on to more complex ones.

    h3 Simple Ticket Machine
    p In this exercise we’re building a very simple ticket machine. You can think of the ticket machine as an automated ticket machine at the cinemas. You insert money, press ok, and get a ticket.


    h4 An interface for the ticket machine
    p Naturally we'll build thins ticket machine as a class. The class will be called <code>TicketMachine</code> and it will contain a number of public methods. Let's describe the class using a <em>C# interface</em>.

    pre
      code.language-csharp
        | interface ITicketMachine {
        |   string InsertMoney(int amount);
        |   string ShowPrice();
        |   string ShowBalance();
        |   string RefundMoney();
        |   string PrintTicket();
        | }


    p.step Open up <em>Visual Studio</em> and create a new <em>C#</em> solution. Make sure you choose <em>C#</em> as the language, and not <em>Visual Basic</em> or any other language.
    p.step Add a new interface file to your project. Call it <code>ITicketMachine</code> and save it as <code>ITicketMachine.cs</code>.
    p.step Make sure your interface looks like the code example above.




    h4 Implementing the interface
    p Let’s create the actual class. The ticket machine that will implement the interace.
    p.step Create a new class called <code>TicketMachine.cs</code> and tell it to implement the interface we just created. Like so:
    pre
      code.language-csharp
        | class TicketMachine : ITicketMachine
        | {
        | }

    p.step Build the project (by pressing <code>F5</code>) and contemplate why it won't build.

    p To make sure the application will build. Let's actually implement the members of the interface in the concrete ticket machine class.


    p.step Open the concrete ticket machine class and right-click the name of the interface in the class definition. Then select <code>Implement Interface &gt; Implement Interface</code>. Or simply implement all of the members of the interface manually.

    pre
      code.language-csharp
        | class TicketMachine : ITicketMachine
        | {
        |   public string InsertMoney(int amount){
        |     throw new NotImplementedException();
        |   }
        |   public string ShowBalance(){
        |     throw new NotImplementedException();
        |   }
        |   public string ShowPrice(){
        |     throw new NotImplementedException();
        |   }
        |   public string RefundMoney(){
        |     throw new NotImplementedException();
        |   }
        |   public string PrintTicket(){
        |     throw new NotImplementedException();
        |   }
        | }

    p Superb! Now we, at least, have an application that builds.


    h4 Command line interface
    p So, now we have the "shell" for a class that will act as the ticket machine. But we need a way to interact with the ticket machine. I.e. we need a class that will use the ticket machine class.

    p For the sake of simplicity you've been provided with a command line interface (CLI) class that you can 
      a(href="https://raw.githubusercontent.com/chrokh/software-engineering-labs/master/block1/code/TicketMachine/TicketMachine/TicketMachineInteractor.cs") download here
      |.

    p In your main <code>Program.cs</code> class you can then interact with the <code>TicketMachineInteractor</code> like so:

    pre
      code.language-csharp
        | class Program{
        |   public static void Main(){
        |     // Instantiate a ticket machine
        |     ITicketMachine tm = new TicketMachine();
        | 
        |     // Instantiate an interactor, and pass in the ticket machine
        |     TicketMachineInteractor interactor = new TicketMachineInteractor(tm);
        | 
        |     // Start the interactor
        |     interactor.Start();
        |   }
        | }


    p Ok, let’s now create a CLI so that we can interact with our TicketMachine class. You should already have a file called Program.cs. Copy and paste the following code into this file. Have a look at the contents of this code and discuss it with a lab partner.

    p.step Try running your application!
    p The output should be similar to this:

    pre.terminal
      | (q) Quit
      | (i) Insert money
      | (b) Show balance
      | (p) Show price
      | (r) Refund money
      | (t) Print ticket
      | ==============================================
      | Choose action (h for help)
      | &gt;
    p If you, when running your application, do make one of the choices above -- of course a <code>NotImplementedException</code> will be thrown because that's all our concerete Ticket Machine does for now.



    h4 Ticket Machine ticket costs
    p Before we get into implementing the body of each method in the concrete ticket machine class -- let's declare a constructor. The constructor will take an integer as an argument. The integer represents the price of a single ticket. Consequently, our constructor needs to save the value passed in, as an instance variable so that we can use it later on. We need it to  Let's do it:
    p.step Implement a constructor in the ticket machine class, that takes an integer as an argument, and saves that value to an instance variable.
    pre
      code.language-csharp
        | class TicketMachine : ITicketMachine{
        |   private int price;
        | 
        |   public TicketMachine (int ticketCost){
        |     this.price = ticketCost;
        |   }
        | }


    h4 Full implementation
    p Now it's time to actually implement the members of the concrete ticket machine class. Below you'll find a runtime example of what a session with the ticket machine could look like.
    pre.terminal
      | Choose action (h for help)
      | &gt;   i
      | &gt;&gt;&gt; Enter the amount you wish to insert (SEK):
      | &gt;   50
      | &gt;&gt;&gt; Inserted 50 kr
      | ==============================================
      | Choose action (h for help)
      | &gt;   t
      | &gt;&gt;&gt; Insufficient funds.. Missing 150 kr
      | ==============================================
      | Choose action (h for help)
      | &gt;   p
      | &gt;&gt;&gt; The price of one ticket is 200 kr
      | ==============================================
      | Choose action (h for help)
      | &gt;   i
      | &gt;&gt;&gt; Enter the amount you wish to insert (SEK):
      | &gt;   175
      | &gt;&gt;&gt; Inserted 175 kr
      | ==============================================
      | Choose action (h for help)
      | &gt;   t
      | &gt;&gt;&gt; Printing ticket....
      | ==============================================
      | Choose action (h for help)
      | &gt;   b
      | &gt;&gt;&gt; Your balance is currently: 25 kr
      | ==============================================
      | Choose action (h for help)
      | &gt;   i
      | &gt;&gt;&gt; Enter the amount you wish to insert (SEK):
      | &gt;   75
      | &gt;&gt;&gt; Inserted 75 kr
      | ==============================================
      | Choose action (h for help)
      | &gt;   r
      | &gt;&gt;&gt; Refunding 100 kr
      | ==============================================
      | Choose action (h for help)
      | &gt;
    p If you find the runtime example above too confusing -- there's some comments below explaining what each method should do. Please note: all the methods return strings that will be printed by the interactor.

    pre
      code.language-csharp
        | public string InsertMoney(int amount){
        |   // update the current balance as defined by amount
        |   // only if amount is greater than 0
        |   // return string that explains what happened
        | }
        | public string ShowBalance(){
        |   // return a string that describes the current balance
        | }
        | public string ShowPrice(){
        |   // return a string that describes the price of a ticket
        | }
        | public string PrintTicket(){
        |   // if balance is enough
        |   //    reduce balance accordingly, and
        |   //    return string describing ticket
        |   // if balance is not enough
        |   //    return error message and amount missing
        | }
        | public string RefundMoney(){
        |   // print the amount of money refunded
        |   // reset the current amount and print it
        | }
    p Consequently the last task of this exercise is to...
    p.step Implement the intended functionality of all the <code>ITicketMachine</code> members in the concrete <code>TicketMachine</code>.







    h3 Contemplation
    p So your ticket machine is fully functional. Yay, celebrate! However, let’s now look at how much abstraction we've achieved with our current implementation of the ticket machine. Does our ticket machine allow different prices, or other payment schemes?

    p Naturally we can change the ticket price at <strong>compile time</strong>:
    pre
      code.language-csharp
        | public static void Main ()
        | { 
        |   ITicketMachine cheap = new TicketMachine (1020);
        |   ITicketMachine expensive = new TicketMachine(40500);
        | ...
    p And naturally we can of course alter the price at <strong>runtime</strong>, by for example allowing the user to specifiy the price of a ticket:
    pre
      code.language-csharp
        | public static void Main ()
        | { 
        |   Console.Write("Specify how much a ticket is in SEK and press enter");
        |   int price = Int32.Parse(Console.ReadLine());
        |   ITicketMachine tm = new TicketMachine (price);
        | ...
    p But there's one thing we haven't really talked about yet. The power of programming towards interfaces. Our ticket machine is actually way more abstract than one might first imagine. Take note of the fact that the <code>TicketMachineInteractor</code> class does <strong>not</strong> accept a <code>TicketMachine</code>, but rather an <code>ITicketMachine</code>. This means that it accepts an instance of any class as long as the given class implements the <code>ITicketMachine</code> interface.













    h3 Donation Machine
    p Let's build a new ticket machine that also implements the <code>ITicketMachine</code> interface, but exhibits different behaviour.
    p.step Create the file <code>DonationMachine.cs</code>} and let it contain the class definition that implements the interface <code>ITicketMachine</code>.
    p.step Implement the body of the members, according to the specification below.
    p The pseudo-code below explains what the donation machine does.
    pre
      code.language-csharp
        | public class DonationMachine : ITicketMachine{
        |   public string InsertMoney(int amount){
        |     // update the current balance as defined by amount
        |     // only if amount is greater than 0
        |     // return string that explains what happened
        |   }
        |   public string ShowBalance (){
        |     // return a string that describes the current balance
        |   }
        |   public string ShowPrice (){
        |     // return a string that describes the minimum donation
        |   }
        |   public string PrintTicket (){
        |     // if balance is greater than minimum donation
        |     //    commit donation by
        |     //      - update total balance with current balance
        |     //      - reset current balance
        |     //      - print total balance
        |     // else
        |     //    return error message and amount missing
        |   }
        |   public string RefundMoney (){
        |     // print the amount of money refunded
        |     // reset the current balance
        |   }
        | }
    p Now we can see why programming towards interfaces is such a powerful idea. Instantiate and send a <code>DonationMachine</code> to the <code>TicketMachineInteractor</code> instead.
    pre
      code.language-csharp
        | class Program{
        |   public static void Main(){
        |     ITicketMachine tm = new DonationMachine(10);
        |     TicketMachineInteractor interactor = new TicketMachineInteractor(tm);
        |     interactor.Start();
        |   }
        | }
    p.step Run the application! And consider how we didn't have to make any modifications to the <code>TicketMachineInteractor</code> class.
    p Because the <code>TicketMachineInteractor</code> class is prpgrammed towards an interface rather than an implementation -- it is fully functional with whatever implementation we choose to build, so long as the implementation implements the <code>ITicketMachine</code> interface.












    h3 Parking Machine
    p While we're at it, let's create another machine. A regular 'ol Swedish parking machine.

    p.step Create a new class called <code>ParkingMachine</code> and let it implement the <code>ITicketMachine</code> interface. It's implementation should follow the specification below.
    ul
      li The price is the value of 10 minutes of parking.
      li The price should (as in the other machines) be set via the constructor.
      li When the user asks for a ticket the ticket must show how many minutes of parking the user receives.
      li Parking time can only be in full multiplications of 10 minutes, the rest the user will receive as change.
      li So, if the price of a ticket is 5 SEK, and the user inserts 13 SEK, the parking time would be 20 minutes, and the change 3 SEK.










    h3 Contemplation
    p Consider again the power of interfaces. While the Ticket machine examples might feel slightly contrived. Take a minute to consider the implications of creating a class like the one below, that inherits from the <code>ITicketMachine</code> interface. Any other class expecting an <code>ITicketMachine</code> can interchangebly use this class.

    pre
      code.language-csharp
        | public class ExternalTicketMachine : ITicketMachine
        | { 
        |   private int price, balance;
        | 
        |   public ExternalTicketMachine ()
        |   {
        |     this.price = // make a web request to get the price of a ticket
        |     this.balance = 0;
        |   }
        |   public string InsertMoney(int amount){
        |     // increase current balance locally
        |   }
        |   public string ShowBalance(){
        |     // return current balance locally
        |   }
        |   public string ShowPrice(){
        |     // make a web request to get the price of a ticket
        |   }
        |   public string PrintTicket(){
        |     // make a web request to an external service
        |     // sending some user details and the current balance
        |     // returning the ticket recieved by the web request call
        |   }
        |   public string RefundMoney(){
        |     // refund money locally
        |   }
        | }
    p.step Write a few sentances (max half a page) about your thoughts on the power of programming towards interfaces. What does it mean to program to an interface rather than an implementation? Is it useful? Why? What are the implications? Many claim we are more ready to cope with change when programming towards interfaces rather than implementations. Is it true? Is it not? Why and how?















  +assignment(2, "GUI Programming &amp; Event Handling")
    p In this assignment we're going to create a GUI for the machines that we built in exercise 1.









  +assignment(3, "Iterator")
    p In this exercise we'll explore the iterator pattern using the phone book example from the lectures.
    ol
      li Create a new <code>C#</code> project, and implement the phone book examples from the notes. But refactor the find method to throw an exception instead of returning <code>-1</code>.
      li Draw a class diagram for the iterator, without using diagram generation in <code>Visual Studio</code>.
      li Implement the <code>iterator pattern</code> for the phone book, populate the phone book and iterate over it, printing its contents.


