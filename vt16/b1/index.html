<!DOCTYPE html><meta charset="utf-8"><html lang="en"><head><title>Block 1</title><link rel="stylesheet" href="/software-engineering-labs/vt16/assets/css/main.css"><link rel="stylesheet" href="/software-engineering-labs/vt16/assets/css/prism.css"><link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css"></head></html><body><div class="container"><header><h1>Software Engineering &mdash; Lab 1</h1></header><div class="preamble"><p>In this first block we'll refresh our object oriented skills by revisiting concepts such as constructors, public and private membership, interfaces and inheritance as well building GUIs using Windows Forms. Finally we'll take our first peek into the world of design patterns by implementing the <em>iterator pattern</em>.</p></div><h2>Seminar hand in</h2><p>Your job is to build a Phone Book as a <code>C#</code> GUI application. Use the phone book example discussed in class as inspiration. Your phone book must support the following functionality:</p><ul><li>CRUD users with first name, last name, address, and phone number.</li><li>CRUD companies with company name, address and phone number.</li><li>CRUD user groups (i.e. collection of users) with name and phone number.</li><li>All CRUD actions must be persistant (e.g. by writing to file)</li><li>You must make use of the iterator pattern** when listing entries.</li></ul><p><em>** Either by using IEnumerable or by implementing the pattern yourself from scratch</em></p><h2>Exercises</h2><h3><a data-target="e1" class="hideable">1.1 Interfaces</a></h3><div id="e1"><p>The purpose of this exercise is to get up to speed, familiarize ourselves with C#, and explore the concept of programming towards interfaces.</p><p>Consider the following scenario. You are running a company that creates encryption algorithms. All algorithms are two-way. In other words, they can encrypt strings as well as decrypt strings.</p><p>Your company is currently aiming to implement all your algorithms in C# and bundle them all as a single DLL.</p><p>To facilitate standardization you've decided to create an interface for what all classes that contain encryption algorithms should look like. See below.</p><pre><code class="language-csharp">interface IAlgorithm {
  string Encrypt(string input);
  string Decrypt(string input);
  string GetName();
}</code></pre><p>Your job is now to create a class for each encryption algorithm. Each class must implement the interface properly, and must encrypt and decrypt according to specification.</p><p>I will show you how to implement the first algorithm, but you then have to implement the rest on your own.</p><p>The following is the specification for the first algorithm.</p><table class="table-border cipher-specification"><tr><th colspan="2">Reversal algorithm</th></tr><tr><td>Name</td><td>The Reversal Algorithm</td></tr><tr><td>Description</td><td>Reverses the input string character by character.</td></tr><tr><td>Example input</td><td><code>"Abc xyz"</code></td></tr><tr><td>Example output</td><td><code>"zyx cbA"</code></td></tr></table><p>Let's implement this algorithm. Create a new visual studio C# console project. Add a new interface file and copy in the <code>IAlgorithm</code> interface. Create a new class and copy in the following code.</p><pre><code class="language-csharp">class ReversalAlgorithm : IAlgorithm
{
  string Encrypt(string input)
  {
    string reversed = "";
    for(int i=input.Length-1; i>=0; i--)
      reversed += input[i];
    return reversed;
  }
  
  string Decrypt(string input)
  {
    return Encrypt(input);
  }
  
  string GetName()
  {
    return "The Reversal Algorithm";
  }
}</code></pre><p>Congratulations, you've now implemented the first one of the algorithms.</p><p>Notice how the class implements the interface in the top using the syntax <code>class ClassName : InterfaceName</code>.</p><p>Notice also how we reuse the Encrypt method in the Decrypt method since they essentially behave the same in this algorithm.</p><p>If you're wondering what the implications are of stating that the <code>ReversalAlgorithm</code> class implents the <code>IAlgorithm</code> interface, try temporarily removing one of the methods from the class and then compile the project by pressing F5. You get an error. Why?</p><p>Make sure your implementation is correct by pasting in the following program in to the main entry point of your application (most often the static <code>Main</code> method of the <code>Program</code> class in the <code>Program.cs</code> file).</p><pre><code class="language-csharp">IAlgorithm algo = new ReversalAlgorithm();
string encrypted = algo.Encrypt("Hello world");
string decrypted = algo.Decrypt("sdrawkcaB");
Console.WriteLine("Hello world => " + encrypted);
Console.WriteLine("sssdrawkcaB => " + decrypted);
Console.ReadKey();</code></pre><pre class="terminal">Hello world => dlrow olleH
sssdrawkcaB => Backwardsss</pre><p>Notice that on the first line in the example program we're declaring the variable <code>algo</code> to be of type <code>IAlgorithm</code> not of type <code>ReversalAlgorithm</code>. This is the power of interfaces. Just like inheritance allows us to declare the base type and then instantiate any of the super types, interfaces allow us to declare the interface and then instantiate any one class that implements that interface.</p><p>This means that we can write programs towards the interfaces without knowing what kind of classes and implementations will show up in the future. As an example. Download the example class in the link below, add it to your project and then rewrite your main program as below.</p><p><a href="../code/block1/Encryptor/Encryptor/EncryptoStream.cs"><i class="fa fa-file-text-o"> EncryptoStream.cs</i></a></p><pre><code class="language-csharp">IAlgorithm algorithm = new ReversalAlgorithm();
 
EncryptoStream stream = new EncryptoStream(algorithm);
 
stream.Start();</code></pre><p>You should now have a program that allows you to interactively encrypt and decrypt strings using your algorithm, and if you type in "Hello world" your terminal screen should look as follows.</p><pre class="terminal">The Reversal Algorithm
 
> Hello world
 
ENCRYPTED: dlrow olleH
 
DECRYPTED: Hello world</pre><p>Let me tell you one final piece before I'll leave you to implementing the rest of the algorithms. Remember that interfaces only specifies the minimal requirements of a class. Interfaces do pose set any further restrictions on the class. This means that each class can do more than just these methods. This will be necessary since some of the algorithms are not as static as the reversal algorithm. The Caesar cipher, for example, requires that you give it a number that represents the number of shifts you want to shift a word with.</p><p>You're now ready to implement the rest of the algorithms. The specifications follow below.</p><table class="table-border cipher-specification"><tr><th colspan="2">Caesar Cipher</th></tr><tr><td>Name</td><td>n-step Caesar Cipher</td></tr><tr><td>Description</td><td><p>Replaces each alphabetical character with an alphabetical character n steps further in the alphabet. The number of steps must be able to be assigned by the code that use the class, through for example the constructor.</p><p>Note: This cipher cannot maintain case (i.e. upper or lower) when decrypting. Nor can it decrypt numbers properly.</p></td></tr><tr><td>Example input</td><td><code>"Abcxyz"</code></td></tr><tr><td>Example output (n=1)</td><td><code>"Bcdyza"</code></td></tr></table><table class="table-border cipher-specification"><tr><th colspan="2">1337 Lang</th></tr><tr><td>Name</td><td>Language of the 1337's</td></tr><tr><td>Description</td><td>Replaces specific characters with numbers. Forces all strings to be lower case before encryption or decryption.</td></tr><tr><td>Charater replacement scheme</td><td><code>a=&gt;4, b=&gt;6, e=&gt;3, g=&gt;9, i=&gt;!, l=&gt;1, o=&gt;0, t=&gt;7</code></td></tr><tr><td>Example input</td><td><code>"Abcxyz"</code></td></tr><tr><td>Example output</td><td><code>"46cxyz"</code></td></tr></table><table class="table-border cipher-specification"><tr><th colspan="2">Multicipher</th></tr><tr><td>Name</td><td>Generic multicipher</td></tr><tr><td>Description</td><td>Any number of <code>IAlgorithm</code> objects can be added to an instance of the <code>Multicipher</code> class at runtime. When encrypting, the algorithm runs each sub-algorithm on the input one after one. When decrypting it runs the algorithms one after one in the reverse order, but decrypting this time.</td></tr><tr><td>Charater replacement scheme</td><td><code>a=&gt;4, b=&gt;6, e=&gt;3, g=&gt;9, i=&gt;!, l=&gt;1, o=&gt;0, t=&gt;7</code></td></tr><tr><td>Example input</td><td><code>"Abcxyz"</code></td></tr><tr><td>Example output (assuming given both CaesarCipher(1) and 1337 Lang in that order)</td><td><code>"6cdyz4"</code></td></tr></table></div><h3><a data-target="e2" class="hideable">1.2 GUI Programming &amp; Event Handling</a></h3><div id="e2"><p>The assignment is now to create a graphical user interface that allows the user to select any combination of algorithms and then encrypt and decrypt strings using that particular combination.</p><p>You are allowed to hard-code the instantiation of the algorithms that the user can choose from.</p><p>Any particular algorithm must be allowed to be used multiple times in the combination.</p><p>The algorithms that the user selects must then be fed into a <code>MultiCipher</code> instance.</p><p>The user can then encrypt and decrypt strings using that particular <code>MultiCipher</code>.</p><p>Design the application any way you wish. See below gif for a runtime example.</p><img src="../assets/img/encryptor-gui-example.gif"></div></div><script src="/software-engineering-labs/vt16/assets/js/prism.js"></script><script src="http://code.jquery.com/jquery-2.1.3.min.js"></script><script src="/software-engineering-labs/vt16/assets/js/main.js"></script></body>