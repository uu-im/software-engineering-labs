\documentclass{article}

\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{color}

\begin{document}

  \title{ Software Engineering | Lab 2 }
  \author{ Uppsala University }
  \date{ Spring 2013 }
  \maketitle

  % csharp code styling
  % (as default to save typing)
  \lstset{
    language=[Sharp]C,
    basicstyle=\color[rgb]{0.3,0.3,0.3}\ttfamily,
    keywordstyle=\color[rgb]{0,0.5,0.5},
    numberstyle=\color[rgb]{0.7,0.7,0.7},
    commentstyle=\color[rgb]{0.1,0.5,0.1},
    stringstyle=\color[rgb]{0.6,0.1,0.5},
    backgroundcolor=\color[rgb]{0.95,0.95,0.95},
    showstringspaces=false
  }

    \paragraph{}
      In this block we'll mainly focus on application testing. While there are many ways to test code we will focus on unit testing. We will be creating the same application three times. First through test-after development (TAD), then test-driven development (TDD), and finally through exceptionally strict TDD. Try to complete the exercises in the same order as outlined below.
    \paragraph{}
      Please feel free to work in pairs and take turns on writing code. Good luck!



\pagebreak{}
\section*{Deliverables}
This is a summary of the deliverables for this block.

\subsubsection*{Exercise 1 -- Introduction to testing}
Three projects and one text file.
\begin{enumerate}
  \item TAD (Visual Studio solution)
  \item TDD (Visual Studio solution)
  \item Sliming (Visual Studio solution)
  \item Contemplation (Text file in .txt-format)
\end{enumerate}

\subsubsection*{Exercise 2 -- Debugging via Tests}
One project and one text file.
\begin{enumerate}
  \item Matrix (Visual Studio solution)
  \item Contemplation (Text file in .txt-format)
\end{enumerate}

\subsubsection*{Exercise 3 -- Test coverage}
One project and one text file.
\begin{enumerate}
  \item PhoneBook (Visual Studio solution)
  \item Contemplation (Text file in .txt-format)
\end{enumerate}

\subsubsection*{Exercise 4 -- TDD practice}
One project and one text file.
\begin{enumerate}
  \item BowlingGameKata (Visual Studio solution)
  \item Contemplation (Text file in .txt-format)
\end{enumerate}

\subsubsection*{Exercise 5 -- Refactoring}
One project and one text file.
\begin{enumerate}
  \item MovieRental (Visual Studio solution)
  \item Contemplation (Text file in .txt-format)
\end{enumerate}




\pagebreak{}
  \section{Introduction to testing}
  \subsection{ Testing existing code (FizzBuzz) }
    \paragraph{}
      You've been provided with a project containing a working implementation of the FizzBuzz problem (from the lectures). Your job is to write unit tests with reasonable coverage. When you are done, it should be hard to introduce errors to the application without also making tests fail. At a minimum, write tests for the following cases:
      \begin{enumerate}
        \item \texttt{Fizz} is returned, when given some number divisible by 3
        \item \texttt{Buzz} is returned, when given some number divisible by 5
        \item \texttt{FizzBuzz} is returned, when given some number divisible by 3 \emph{and} 5
        \item The input number itself is returned, when given some input number not divisible by 3 \emph{nor} 5
      \end{enumerate}
     If you can't remember what the rules of the FizzBuzz game is | the above cases is basically an explanation for the rules of the game (if you change the word "some" for "any").
    \paragraph{Are these tests enough?}
      While the answer to this question of course greatly depends on how you have written your tests, it is quite likely that the answer is no. Do keep this question in mind as you approximate the section on "sliming".

  \subsection{ Test-driven development (FizzBuzz) }
    \paragraph{}
      Create a new console project. We're now going to build the FizzBuzz application again, but this time through test-driven development (TDD). Basically this means that we must build our application only by iterating the steps below:
      \begin{enumerate}
        \item Introduce a (or change an existing) test
        \item Watch the test fail (for the right reason)
        \item Write the minimal code needed to make it pass
      \end{enumerate}

    Different schools of thought argue the meaning of "minimal code needed". However, in this exercise, think of it as: writing the simplest production code possible, that reflects the "idea" of the test, making it pass.

    An easy way to remember the above steps is to think of the idiom red-green-refactor. Basically it means that we should produce a state where some test fail (red). Then write enough code to make it pass (green). Only then, are we allowed to refactor code.

    \subsubsection*{New requirements}
    This time we'll introduce a new requirements. Apart from the \texttt{FizzOrBuzz(int n)} method you should add another public method to the Fizzbuzzer:

    \begin{lstlisting}
string Count(int n);
  // Where n represent the number to count to
  // Example, if n = 5 then the output should be
  // "1 2 Fizz 4 Buzz"
    \end{lstlisting}

  \subsection{ "Sliming" (FizzBuzz) }
    \paragraph{}
      Create a new console project. Once again, we'll build the FizzBuzz application (with the new requirement). Once again, will we use use TDD. However this time we will "slime" every step of implementation.

      Sliming (fake it 'til you make it) is a tactic used as a means to force yourself to ensure high test-coverage. Usually, when we are "writing the minimal code needed, we tend to write "sensible" code (the implementation we actually want). However "sliming" propose we should really write the simplest possible code, no matter how dumb it is.

      Say the goal is to produce the function \texttt{F(x)=x*x}. Then say we write a test, that calls \texttt{F(2)}, and expects (asserts) a return value of \texttt{4}. If we are "sliming", then we write the simplest function we can possibly write to ensure the test is satisfied. So we write the following function:

      \begin{lstlisting}
int f(int x){
  return 4;
}
      \end{lstlisting}

      Unintelligent code indeed. Say we continue by writing a new test, calling \texttt{F(10)}, that expects a return value of \texttt{100}. Since we are sliming, we will change our production code to the following:

      \begin{lstlisting}
int f(int x){
  return x == 2 ? 4 : 100;
}
      \end{lstlisting}

      Utterly stupid code, and as humans we know this is not even close to the final behaviour we want. However, by doing this process, we are forced to write more (or better) tests. We only stop sliming when it becomes harder than writing the implementation we actually want to write.

  \subsection{ Contemplation (TDD vs TAD) }
    \paragraph{}
      What are the positives and negatives of TDD? TAD? Write a few sentances (max half-a-page) about your thoughts on these concepts. When are they good to use? Less good? Was sliming helpful? Always? Who are tests for? Is testing useful for only one or many things?









  \pagebreak
  \section{ Debugging using tests (Matrix) }
    \paragraph{}
      You have been provided with code for a class that handles mathematical operations on Matrices. A class which supposedly was written by a really lousy programmer. It does not behave as expected. Your job is to use either TDD or TAD to provide the matrix class with desired behaviour (free from logical errors). Use testing as a means of localizing errors.

      A matrix is a two-dimensional array of elements (in this case numbers). If you are not familiar with matrices, consult Wikipedia (as a suggestion) to learn how matrix multiplication is performed, and how to calculate the inverse of a 2x2 matrix. Knowledge about matrix operations is vital to write good test cases, and to solve this assignment.






\pagebreak
\section{ Test coverage (Phone book) }
  \paragraph{}
    You've been provided with a class, simliar to the previously discussed phone book example. Your job is to write tests for this class, attempting to achieve \emph{as high test coverage as possible}. In a perfect world it will be impossible to introduce errors to the class without any tests failing.

    You may change the code of the class if you wish, but you are \emph{not} allowed to introduce new public methods to the class, nor change the method signatures of the existing ones.

    When you believe you have achieved a high level of coverage. Grab a friend and let her or him try to make your tests report false-positives. A false-positive is when a test is passing, but the functionality it is supposed to test has actually been broken. It is easy to get snowblind watching your own code so having someone else attempting to "break" it is usually a good idea.

\subsection{ Contemplation (Test-coverage) }
  \paragraph{}
    Does full test-coverage ensure perfect code? Write a few sentances (max half-a-page) about your thoughts on the positives and negatives of test-coverage. What is it good for? Not good for? How good is it? When is it relevant? When not? Is there a golden mean? Etc.







\pagebreak
\section{ TDD practice (Bowling game kata)}
  \paragraph{}
  If you are finished with all of the above, this \emph{optional} exercise allows you to practice your TDD skills by doing the Bowling game kata. You've been provided with some basic code to get you started with the exercise. The bowling game class exposes two public methods whose bodies you need to implement.
  
    \begin{lstlisting}
void Roll(int pins)
  // Where pins is the number of pins knocked
  // down by the player in this roll

int Score()
  // Returns the current score at the given time
    \end{lstlisting}

    \subsection*{ The rules of bowling }
      \begin{enumerate}
        \item Each game consist of 10 frames (rounds)
        \item Each frame consist of 2 rolls
        \item Each roll can knock down 0-10 pins
        \item The score for the frame is the total number of pins knocked down in that frame + plus bonuses for strikes and spares
        \item A spare is when the player knocks down all 10 pins in two rolls
        \item The score of a spare is the number of pins knocked down in the next roll
        \item A strike is when the player knocks down all 10 pins in the first roll
        \item The score of a strike is the number of pins knocked down in the next frame
        \item A frame only consist of one roll if the player rolls a strike
        \item In the tenth frame the player will have one extra roll \emph{if} a strike or spare is rolled
      \end{enumerate}

      \paragraph{ Remember! }
        Red-green-refactor.







\pagebreak
\section{ Refactoring (Movie rental case) }
  \paragraph{}
  Now, it's time to forget about testing (for now) and instead focus on refactoring. The lousy programmer has been at it again. He or she has built a system for a movie rental shop handling customer orders. However, since the lousy programmer was focused on meeting the deadline the code is way more procedural than object oriented.
  
  The \texttt{Customer} class has a \texttt{Statement()} method, that returns a string of information on a given customers current rentals. However, as a requirement to print the statement as a HTML formatted string just came in, the lousy programmer realized the code is not at all prepared for change.
  
  Your job is now to refactor the system so that the new method can be implemented without introducing significant duplication.

  \subsection*{Ideas on what to refactor}
  A good place to start is to have a look at the \texttt{Statement()} method itself. It is way too long! Apart from that, think about the following points:

  \begin{description}
    \item[Method extraction] Can some behavior be extracted into a different method?
    \item[Replacing case statements] Can we use inheritance instead of case statements?
    \item[Creation methods] Can we use creation methods to make instantiation safer?
    \item[Moving behavior] Should a given behavior really be defined on another class? A rule-of-thumb is to consider the Law of Demeter, which say that a class should \emph{only} talk to its closest neighbors. Meaning, it's OK to say:

    \texttt{instanceOfSomeClass.Method()}

    But it's not OK to say:
    
    \texttt{instanceOfSomeClass.instanceOfSomeOtherClass.Method()}
  \end{description}


\section*{}
  \paragraph{ Good luck! }


\end{document}
